<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Lattice Boltzmann Method ‚Äî Interactive Tutorial</title>
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Crimson+Pro:ital,wght@0,300;0,400;0,600;1,300;1,400&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"
  onload="
    window.katexOpts = {
      delimiters:[
        {left:'$$',  right:'$$',  display:true},
        {left:'\\[', right:'\\]', display:true},
        {left:'\\(', right:'\\)', display:false}
      ],
      throwOnError: false
    };
    renderMathInElement(document.body, window.katexOpts);
  "></script>
<style>
  :root {
    --bg: #080c10;
    --surface: #0d1520;
    --surface2: #111d2e;
    --border: #1e3a5f;
    --accent: #00d4ff;
    --accent2: #ff6b35;
    --accent3: #39ff14;
    --text: #c8dff0;
    --text-dim: #5a7a9a;
    --text-bright: #e8f4ff;
    --highlight: rgba(0, 212, 255, 0.08);
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Crimson Pro', Georgia, serif;
    font-size: 18px;
    line-height: 1.7;
    min-height: 100vh;
  }

  /* Starfield background */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background-image:
      radial-gradient(1px 1px at 20% 30%, rgba(0,212,255,0.3) 0%, transparent 100%),
      radial-gradient(1px 1px at 80% 10%, rgba(0,212,255,0.2) 0%, transparent 100%),
      radial-gradient(1px 1px at 50% 80%, rgba(255,107,53,0.2) 0%, transparent 100%),
      radial-gradient(600px at 10% 50%, rgba(0,212,255,0.04) 0%, transparent 70%),
      radial-gradient(400px at 90% 20%, rgba(255,107,53,0.04) 0%, transparent 70%);
    pointer-events: none;
    z-index: 0;
  }

  .wrapper {
    position: relative;
    z-index: 1;
    max-width: 1100px;
    margin: 0 auto;
    padding: 0 24px 80px;
  }

  /* Header */
  header {
    padding: 60px 0 40px;
    border-bottom: 1px solid var(--border);
    margin-bottom: 60px;
  }

  .tag {
    font-family: 'Space Mono', monospace;
    font-size: 11px;
    color: var(--accent);
    letter-spacing: 3px;
    text-transform: uppercase;
    margin-bottom: 16px;
    opacity: 0.8;
  }

  h1 {
    font-family: 'Crimson Pro', serif;
    font-size: clamp(2.4rem, 5vw, 4rem);
    font-weight: 300;
    color: var(--text-bright);
    letter-spacing: -0.5px;
    line-height: 1.15;
  }

  h1 em {
    font-style: italic;
    color: var(--accent);
  }

  .subtitle {
    margin-top: 16px;
    font-size: 1.1rem;
    color: var(--text-dim);
    font-weight: 300;
    max-width: 560px;
  }

  /* Nav dots */
  .chapter-nav {
    display: flex;
    gap: 8px;
    margin-top: 32px;
    flex-wrap: wrap;
  }

  .chapter-nav button {
    font-family: 'Space Mono', monospace;
    font-size: 11px;
    padding: 6px 14px;
    background: transparent;
    border: 1px solid var(--border);
    color: var(--text-dim);
    cursor: pointer;
    letter-spacing: 1px;
    transition: all 0.2s;
    border-radius: 2px;
  }

  .chapter-nav button:hover,
  .chapter-nav button.active {
    border-color: var(--accent);
    color: var(--accent);
    background: var(--highlight);
  }

  /* Sections */
  .section {
    display: none;
    animation: fadeIn 0.4s ease;
  }

  .section.active { display: block; }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(12px); }
    to { opacity: 1; transform: translateY(0); }
  }

  h2 {
    font-family: 'Crimson Pro', serif;
    font-size: 2rem;
    font-weight: 300;
    color: var(--text-bright);
    margin-bottom: 8px;
  }

  h2 .num {
    font-family: 'Space Mono', monospace;
    font-size: 12px;
    color: var(--accent);
    letter-spacing: 2px;
    display: block;
    margin-bottom: 6px;
  }

  h3 {
    font-family: 'Space Mono', monospace;
    font-size: 13px;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--accent2);
    margin: 36px 0 12px;
  }

  p { margin-bottom: 1.2em; color: var(--text); }

  strong { color: var(--text-bright); font-weight: 600; }

  em { color: var(--accent); font-style: italic; }

  /* Formula blocks */
  .formula {
    background: var(--surface);
    border: 1px solid var(--border);
    border-left: 3px solid var(--accent);
    padding: 20px 24px;
    margin: 24px 0;
    font-family: 'Space Mono', monospace;
    font-size: 14px;
    color: var(--accent);
    line-height: 2;
    overflow-x: auto;
  }

  .formula .label {
    font-family: 'Crimson Pro', serif;
    font-size: 12px;
    color: var(--text-dim);
    letter-spacing: 1px;
    text-transform: uppercase;
    display: block;
    margin-bottom: 8px;
  }

  /* Info boxes */
  .info-box {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 20px 24px;
    margin: 24px 0;
    position: relative;
  }

  .info-box::before {
    content: attr(data-label);
    position: absolute;
    top: -10px;
    left: 16px;
    background: var(--bg);
    padding: 0 8px;
    font-family: 'Space Mono', monospace;
    font-size: 10px;
    letter-spacing: 2px;
    color: var(--accent2);
    text-transform: uppercase;
  }

  /* Grid illustration */
  .grid-demo {
    display: flex;
    gap: 40px;
    align-items: flex-start;
    flex-wrap: wrap;
    margin: 32px 0;
  }

  .d2q9-grid {
    display: grid;
    grid-template-columns: repeat(3, 56px);
    grid-template-rows: repeat(3, 56px);
    gap: 2px;
    flex-shrink: 0;
  }

  .d2q9-cell {
    background: var(--surface2);
    border: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'Space Mono', monospace;
    font-size: 11px;
    color: var(--text-dim);
    position: relative;
    cursor: pointer;
    transition: all 0.2s;
  }

  .d2q9-cell.center {
    background: rgba(0,212,255,0.15);
    border-color: var(--accent);
    color: var(--accent);
  }

  .d2q9-cell:hover:not(.center) {
    background: rgba(0,212,255,0.05);
    border-color: rgba(0,212,255,0.4);
  }

  .d2q9-cell .arrow {
    position: absolute;
    font-size: 18px;
    color: var(--accent2);
    pointer-events: none;
  }

  .d2q9-cell .vel-label {
    position: absolute;
    bottom: 3px;
    right: 4px;
    font-size: 8px;
    color: var(--accent2);
    font-family: 'Space Mono', monospace;
  }

  /* Simulation canvas area */
  .sim-container {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 24px;
    margin: 32px 0;
    resize: vertical;          /* browser native resize ‚Äî works on the container */
  }

  /* Resizable sim canvas wrapper */
  .sim-canvas-wrap {
    position: relative;
    width: 100%;
    max-width: 680px;
    margin: 0 auto;
    border: 1px solid var(--border);
    border-radius: 2px;
    overflow: hidden;
  }

  .sim-resize-bar {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 6px;
    font-family: 'Space Mono', monospace;
    font-size: 10px;
    color: var(--text-dim);
    user-select: none;
  }

  .sim-resize-bar input[type=range] {
    width: 110px;
    accent-color: var(--accent);
    cursor: pointer;
  }

  .sim-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
    flex-wrap: gap;
    gap: 12px;
  }

  .sim-title {
    font-family: 'Space Mono', monospace;
    font-size: 12px;
    letter-spacing: 2px;
    color: var(--accent);
    text-transform: uppercase;
  }

  .sim-controls {
    display: flex;
    gap: 10px;
    align-items: center;
    flex-wrap: wrap;
  }

  .btn {
    font-family: 'Space Mono', monospace;
    font-size: 11px;
    padding: 8px 16px;
    border: 1px solid var(--border);
    background: transparent;
    color: var(--text);
    cursor: pointer;
    letter-spacing: 1px;
    transition: all 0.2s;
    border-radius: 2px;
  }

  .btn:hover { border-color: var(--accent); color: var(--accent); }

  .btn.primary {
    border-color: var(--accent);
    color: var(--accent);
    background: var(--highlight);
  }

  .btn.primary:hover { background: rgba(0,212,255,0.15); }

  .btn.danger { border-color: #ff4466; color: #ff4466; }
  .btn.danger:hover { background: rgba(255,68,102,0.1); }

  canvas {
    display: block;
    width: 100%;
    image-rendering: pixelated;
    border: 1px solid var(--border);
    cursor: crosshair;
  }


  .param-row {
    display: flex;
    gap: 24px;
    margin-top: 16px;
    flex-wrap: wrap;
    align-items: center;
  }

  .param-group {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 140px;
  }

  .param-group label {
    font-family: 'Space Mono', monospace;
    font-size: 10px;
    letter-spacing: 1px;
    color: var(--text-dim);
    text-transform: uppercase;
  }

  .param-group input[type=range] {
    accent-color: var(--accent);
    width: 140px;
  }

  .param-val {
    font-family: 'Space Mono', monospace;
    font-size: 12px;
    color: var(--accent);
  }

  /* Legend */
  .legend {
    display: flex;
    gap: 20px;
    margin-top: 12px;
    flex-wrap: wrap;
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 13px;
    color: var(--text-dim);
    font-family: 'Space Mono', monospace;
  }

  .legend-swatch {
    width: 24px;
    height: 12px;
    border-radius: 2px;
  }

  /* Stepwise list */
  .step-list {
    counter-reset: step;
    list-style: none;
    margin: 24px 0;
  }

  .step-list li {
    counter-increment: step;
    display: flex;
    gap: 20px;
    margin-bottom: 24px;
    padding-bottom: 24px;
    border-bottom: 1px solid rgba(30,58,95,0.5);
  }

  .step-list li:last-child { border-bottom: none; }

  .step-num {
    font-family: 'Space Mono', monospace;
    font-size: 11px;
    color: var(--accent);
    letter-spacing: 2px;
    min-width: 36px;
    padding-top: 3px;
    opacity: 0.7;
  }

  .step-num::before { content: counter(step, decimal-leading-zero); }

  /* Quiz */

  /* Progress bar */
  .progress-bar {
    height: 2px;
    background: var(--border);
    margin-bottom: 40px;
    position: relative;
  }

  .progress-fill {
    height: 100%;
    background: var(--accent);
    transition: width 0.4s ease;
    box-shadow: 0 0 8px var(--accent);
  }

  /* section nav footer */
  .section-nav {
    display: flex;
    justify-content: space-between;
    margin-top: 60px;
    padding-top: 24px;
    border-top: 1px solid var(--border);
  }

  /* Velocity arrows overlay canvas */
  #velCanvas { display: block; }

  .two-col {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 32px;
    margin: 24px 0;
  }

  .slbm-grid {
    display: grid;
    grid-template-columns: 1fr 220px;
    gap: 20px;
    align-items: start;
  }
  @media (max-width: 700px) {
    .slbm-grid {
      grid-template-columns: 1fr;
    }
    .slbm-grid > div {   /* sidebar */
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      font-size: 10px;
    }
  }
  @media (max-width: 640px) {
    .two-col { grid-template-columns: 1fr; }
    .grid-demo { flex-direction: column; }
  }

  /* Scrollbar */
  ::-webkit-scrollbar { width: 6px; height: 6px; }
  ::-webkit-scrollbar-track { background: var(--bg); }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

  .highlight-box {
    background: rgba(0,212,255,0.05);
    border: 1px solid rgba(0,212,255,0.2);
    border-radius: 4px;
    padding: 16px 20px;
    margin: 20px 0;
  }

  .sc-track {
    flex: 1;
    padding: 8px 4px;
    text-align: center;
    cursor: pointer;
    color: var(--text-dim);
    letter-spacing: 1px;
    transition: all 0.2s;
    border-right: 1px solid var(--border);
    font-size: 9px;
  }
  .sc-track:last-child { border-right: none; }
  .sc-track:hover { background: rgba(0,212,255,0.05); color: var(--text); }
  .active-track { background: rgba(0,212,255,0.12) !important; color: var(--accent) !important; }
  .hq-phase-btn.active-phase { border-color: var(--accent); color: var(--accent); background: var(--highlight); }

  @media (max-width: 780px) {
    #scMainLayout { grid-template-columns: 1fr !important; }
  }

  code {
    font-family: 'Space Mono', monospace;
    font-size: 0.82em;
    color: var(--accent2);
    background: rgba(255,107,53,0.1);
    padding: 1px 5px;
    border-radius: 2px;
  }
</style>
</head>
<body>
<div class="wrapper">

  <header>
    <div class="tag">// Interactive Tutorial</div>
    <h1>The <em>Lattice Boltzmann</em><br>Method</h1>
    <p class="subtitle">A computational approach to simulating fluid dynamics through the statistical mechanics of particles on a lattice.</p>

    <nav class="chapter-nav" id="chapNav">
      <button class="active" onclick="goSection(0)">01 ¬∑ Introduction</button>
      <button onclick="goSection(1)">02 ¬∑ The Lattice</button>
      <button onclick="goSection('1b')">02b ¬∑ Hermite Roots</button>
      <button onclick="goSection(2)">03 ¬∑ Distributions</button>
      <button onclick="goSection(3)">04 ¬∑ Algorithm</button>
      <button onclick="goSection(4)">05 ¬∑ Stream &amp; Collide</button>
      <button onclick="goSection(5)">06 ¬∑ Lid-Driven Cavity</button>
      <button onclick="goSection(6)">07 ¬∑ K√°rm√°n Vortex Street</button>
      <button onclick="goSection(7)">08 ¬∑ Applications</button>
      <button onclick="goSection(8)">09 ¬∑ Semi-Lagrangian LBM</button>
    </nav>
  </header>

  <div class="progress-bar"><div class="progress-fill" id="progressFill" style="width:14.3%"></div></div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       SECTION 0: Introduction
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <section class="section active" id="sec0">
    <h2><span class="num">01 ¬∑ OVERVIEW</span>What is the Lattice Boltzmann Method?</h2>

    <p>Unlike traditional computational fluid dynamics (CFD) methods that discretize the <strong>Navier-Stokes equations</strong> directly, the Lattice Boltzmann Method (LBM) takes a radically different approach: instead of tracking the fluid as a continuous medium, it simulates the statistical behavior of <em>fictitious particles</em> streaming and colliding on a regular lattice.</p>

    <p>Emerging from <strong>lattice gas automata</strong> in the late 1980s, LBM has become one of the most powerful tools for simulating complex flows ‚Äî from turbulence and multiphase systems to flows through porous media and microfluidics.</p>

    <div class="two-col">
      <div class="info-box" data-label="Why LBM?">
        <p style="margin:0">LBM is <strong>naturally parallel</strong> ‚Äî local operations on a grid map beautifully to GPU architectures. It handles <strong>complex geometries</strong> with simple boundary rules, and multi-phase / multi-component extensions are elegant.</p>
      </div>
      <div class="info-box" data-label="The Core Idea">
        <p style="margin:0">Fluid macroscopic quantities (density œÅ, velocity <strong>u</strong>) are <em>moments</em> of a particle distribution function <em>f</em>. We evolve <em>f</em> by streaming particles and relaxing them toward local equilibrium.</p>
      </div>
    </div>

    <div class="info-box" data-label="Weak Compressibility">
      <p style="margin:0">Standard LBM is <strong>weakly compressible</strong> by construction &mdash; unlike incompressible Navier-Stokes solvers, it permits small density fluctuations. The density error scales as \(O(Ma^2)\) where \(Ma = |\mathbf{u}|/c_s\). To approximate incompressible flow, simulations must use low velocities (\(Ma \lesssim 0.1\)), keeping density variations below ~1%.</p>
    </div>

    <h3>Historical Context &amp; Derivation</h3>
    <p>The method descends from the <strong>Boltzmann equation</strong> (1872), which describes the statistical evolution of a gas's distribution function. In the BGK approximation (no body force):</p>

    <div class="formula">
      <span class="label">Boltzmann‚ÄìBGK Equation</span>
      $$\frac{\partial f}{\partial t} + \boldsymbol{\xi} \cdot \nabla f = -\frac{f - f^{\mathrm{eq}}}{\tau}$$
    </div>

    <p>LBM arrives at a tractable discrete update by applying three steps to this equation:</p>

    <ol style="margin:0.4em 0 1em 1.4em; line-height:2.1;">
      <li><strong>Velocity-space discretization via Gauss&ndash;Hermite quadrature</strong>: \(f(\mathbf{x},\boldsymbol{\xi},t)\) is projected onto a Hermite polynomial basis. The quadrature nodes become the discrete lattice velocities \(\mathbf{e}_i\) and the weights become \(w_i\) ‚Äî uniquely fixed by the quadrature, not chosen arbitrarily. For D2Q9 these nodes also determine \(c_s^2 = \tfrac{1}{3}\).</li>
      <li><strong>Equilibrium expansion</strong>: \(f^\mathrm{eq}\) is approximated by its second-order Hermite expansion in the <em>flow</em> velocity \(\mathbf{u}\) (valid for \(Ma \ll 1\)), giving \(f_i^\mathrm{eq} = w_i\rho\bigl[1 + \tfrac{\mathbf{e}_i\cdot\mathbf{u}}{c_s^2} + \tfrac{(\mathbf{e}_i\cdot\mathbf{u})^2}{2c_s^4} - \tfrac{u^2}{2c_s^2}\bigr]\).</li>
      <li><strong>Time integration</strong>: the trapezoidal rule plus a variable substitution (He &amp; Luo 1997) yields the explicit update \(f_i^* = f_i - \tfrac{1}{\tau}[f_i - f_i^\mathrm{eq}]\) in lattice units (\(\Delta t=1\)). The substitution re-parametrises: the physical relaxation time \(\tau_\text{phys}\) (in seconds) maps to the LBM parameter \(\tau = \tau_\text{phys}/\Delta t - \tfrac{1}{2}\). Throughout this tutorial \(\tau\) always refers to this LBM parameter, so the viscosity formula \(\nu = \tfrac{1}{3}(\tau-\tfrac{1}{2})\) is consistent as written.</li>
    </ol>
      <div class="quiz-feedback" id="quizFeedback0"></div>
    </div>

    <div class="section-nav">
      <span></span>
      <button class="btn primary" onclick="goSection(1)">Next: The Lattice ‚Üí</button>
    </div>
  </section>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       SECTION 1: The Lattice
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <section class="section" id="sec1">
    <h2><span class="num">02 ¬∑ DISCRETIZATION</span>The D2Q9 Lattice</h2>

    <p>LBM uses a notation <em>DnQm</em> where <strong>n</strong> is the number of spatial dimensions and <strong>m</strong> is the number of discrete velocity directions. The most common 2D scheme is <em>D2Q9</em> ‚Äî a 2D lattice where each node has <strong>9 possible velocity directions</strong> (including rest).</p>

    <div class="grid-demo">
      <div>
        <div class="d2q9-grid" id="d2q9Grid"></div>
        <p style="font-size:13px; color:var(--text-dim); margin-top:12px; font-family:'Space Mono',monospace;">‚Üë Hover cells to explore velocities</p>
      </div>
      <div style="flex:1; min-width:260px;">
        <p>Each node on the lattice maintains <strong>9 distribution functions</strong> f‚ÇÄ‚Ä¶f‚Çà, one for each velocity direction. The velocity set is:</p>
        <div class="formula">
          $$\mathbf{e}_0=(0,0),\quad \mathbf{e}_{1\text{-}4}\in\{(\pm1,0),(0,\pm1)\},\quad \mathbf{e}_{5\text{-}8}\in\{(\pm1,\pm1)\}$$
        </div>
        <p style="font-size:0.88em;color:var(--text-dim);margin-top:8px;">Exact index labelling of \(\mathbf{e}_1\ldots\mathbf{e}_8\) varies by convention; only the full set matters for the physics. The Gauss&ndash;Hermite quadrature nodes that generate this set also fix \(c_s^2 = \tfrac{1}{3}\) (lattice units), which appears throughout the theory.</p>
        <div id="cellInfo" class="highlight-box">
          <p style="margin:0; font-family:'Space Mono',monospace; font-size:13px; color:var(--accent)">
            ‚Üê Click a cell to see its velocity vector and weight
          </p>
        </div>
      </div>
    </div>

    <h3>Lattice Weights</h3>
    <p>Each direction carries a <strong>weight</strong> w·µ¢ used in the equilibrium distribution. For D2Q9:</p>
    <div class="formula">
      <span class="label">Lattice Weights (D2Q9)</span>
      $$w_0 = \tfrac{4}{9}, \qquad w_{1\text{-}4} = \tfrac{1}{9}, \qquad w_{5\text{-}8} = \tfrac{1}{36}$$
    </div>
    <p>The weights \(w_i\) arise from <strong>Gauss&ndash;Hermite quadrature</strong> of velocity space. The continuous Maxwell-Boltzmann equilibrium is expanded in a Hermite polynomial basis; the weights are fixed so that the key moment tensors of the Maxwellian are reproduced exactly up to fourth order ‚Äî specifically \(\sum_i w_i = 1\), \(\sum_i w_i e_{i\alpha} e_{i\beta} = c_s^2\delta_{\alpha\beta}\), and the fourth-order tensor \(\sum_i w_i e_{i\alpha}e_{i\beta}e_{i\gamma}e_{i\delta}\) matching its continuous counterpart. These conditions are necessary and sufficient to recover isotropic Navier-Stokes dynamics at second order in the Knudsen number. The geometric difference between link lengths (\(\sqrt{2}\) vs.\(1\)) is a <em>consequence</em> of this derivation, not its cause.</p>

    <h3>The Lattice in 3D</h3>
    <p>For 3D simulations, <em>D3Q19</em> (19 velocities) or <em>D3Q27</em> (27 velocities) are common. The same principles apply: more velocities allow higher-order moments to be reproduced exactly, reducing anisotropy errors at the cost of memory and compute.</p>

    <p>D3Q27 is the natural 3D extension of D2Q9 ‚Äî a full 3√ó3√ó3 tensor product of {‚àí1, 0, +1} in each axis. Every node connects to all 26 neighbours plus itself. The weights follow the same Gauss‚ÄìHermite logic, now in three dimensions:</p>

    <div class="formula">
      <span class="label">D3Q27 Weights</span>
      $$w_{\mathbf{e}} = w_{e_x}\,w_{e_y}\,w_{e_z}, \quad w_0=	frac{2}{3},\; w_{\pm1}=	frac{1}{6} \;\Rightarrow\; w_{000}=	frac{8}{27},\; w_{	ext{face}}=	frac{2}{27},\; w_{	ext{edge}}=	frac{1}{54},\; w_{	ext{corner}}=	frac{1}{216}$$
    </div>

    <!-- D3Q27 interactive canvas -->
    <div style="background:var(--surface);border:1px solid var(--border);border-radius:4px;padding:20px 24px;margin:20px 0;">

      <!-- Row 1: stencil selector -->
      <div style="display:flex;align-items:center;gap:10px;margin-bottom:10px;flex-wrap:wrap;">
        <span style="font-family:'Space Mono',monospace;font-size:10px;color:var(--text-dim);letter-spacing:1px;white-space:nowrap;">STENCIL:</span>
        <button class="btn d3q27-stencil-btn" id="d3q27Btn15" onclick="d3q27SetStencil(15)" style="font-size:11px;">D3Q15</button>
        <button class="btn d3q27-stencil-btn" id="d3q27Btn19" onclick="d3q27SetStencil(19)" style="font-size:11px;">D3Q19</button>
        <button class="btn d3q27-stencil-btn active-layer" id="d3q27Btn27" onclick="d3q27SetStencil(27)" style="font-size:11px;">D3Q27</button>

        <button class="btn" onclick="d3q27Reset()" style="margin-left:4px;">‚Ü∫</button>
      </div>

      <!-- Row 2: stencil description -->
      <div id="d3q27StencilDesc" style="font-family:'Space Mono',monospace;font-size:10px;color:var(--text-dim);margin-bottom:14px;line-height:1.8;padding:8px 10px;background:rgba(0,212,255,0.04);border:1px solid var(--border);border-radius:2px;"></div>

      <!-- Row 3: canvas + info -->
      <div style="display:grid;grid-template-columns:1fr 260px;gap:20px;align-items:start;">
        <div>
          <canvas id="d3q27Canvas" width="480" height="420"
            style="width:100%;display:block;border:1px solid var(--border);border-radius:2px;background:#070b12;cursor:grab;"
            onmousedown="d3q27MouseDown(event)" onmousemove="d3q27MouseMove(event)"
            onmouseup="d3q27MouseUp()" onmouseleave="d3q27MouseUp()"
            ontouchstart="d3q27TouchStart(event)" ontouchmove="d3q27TouchMove(event)" ontouchend="d3q27MouseUp()">
          </canvas>
          <p style="font-family:'Space Mono',monospace;font-size:10px;color:var(--text-dim);margin-top:6px;">
            üñ± Drag to rotate ¬∑ Select stencil ¬∑ Hover for node info
          </p>
        </div>
        <div id="d3q27Info" style="font-family:'Space Mono',monospace;font-size:11px;line-height:2;color:var(--text-dim);">
          <div style="color:var(--accent);font-size:10px;letter-spacing:1px;margin-bottom:8px;">NODE INFO</div>
          <div>Hover a node to inspect</div>
        </div>
      </div>

      <!-- Legend -->
      <div style="display:flex;gap:20px;margin-top:12px;flex-wrap:wrap;font-family:'Space Mono',monospace;font-size:10px;color:var(--text-dim);">
        <span>‚óè <span style="color:#00d4ff">Centre</span> ‚Äî rest, |e|=0</span>
        <span>‚óè <span style="color:#4ade80">Face</span> ‚Äî |e|=1</span>
        <span>‚óè <span style="color:#f97316">Edge</span> ‚Äî |e|=‚àö2</span>
        <span>‚óè <span style="color:#a78bfa">Corner</span> ‚Äî |e|=‚àö3</span>
        <span style="color:rgba(100,120,140,0.6)">‚óè Dimmed = excluded from stencil</span>
      </div>
    </div>

    <div class="section-nav">
      <button class="btn" onclick="goSection(0)">‚Üê Introduction</button>
      <button class="btn primary" onclick="goSection(2)">Next: Distributions ‚Üí</button>
    </div>
  </section>


  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       SECTION 1b: Gauss‚ÄìHermite Quadrature & Tensor Products
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <section class="section" id="sec1b">
    <h2><span class="num">02b ¬∑ DERIVATION</span>From Hermite Roots to D1Q3, D2Q9, D3Q27</h2>

    <p>The discrete velocity set is not chosen arbitrarily ‚Äî it falls out of <strong>Gauss‚ÄìHermite quadrature</strong>. The roots of the degree-3 probabilists' Hermite polynomial He‚ÇÉ(Œæ) give a 1D three-point stencil called <em>D1Q3</em>. Taking the tensor product with itself yields <em>D2Q9</em>; one more tensor product gives <em>D3Q27</em>.</p>

    <div style="background:var(--surface);border:1px solid var(--border);border-radius:4px;padding:20px 24px;margin:20px 0;">

      <!-- Phase buttons + controls -->
      <div style="display:flex;align-items:center;gap:8px;margin-bottom:12px;flex-wrap:wrap;">
        <button class="btn hq-phase-btn active-phase" id="hqBtn0" onclick="hqGoPhase(0)">1 ¬∑ He‚ÇÉ ROOTS</button>
        <button class="btn hq-phase-btn" id="hqBtn1" onclick="hqGoPhase(1)">2 ¬∑ D1Q3</button>
        <button class="btn hq-phase-btn" id="hqBtn2" onclick="hqGoPhase(2)">3 ¬∑ ‚äó D2Q9</button>
        <button class="btn hq-phase-btn" id="hqBtn3" onclick="hqGoPhase(3)">4 ¬∑ ‚äó D3Q27</button>
        <div style="flex:1;min-width:8px;"></div>
        <button class="btn" id="hqPauseBtn" onclick="hqToggle()" style="padding:5px 14px;font-size:10px;">‚ñ† PAUSE</button>
        <label style="font-family:'Space Mono',monospace;font-size:10px;color:var(--text-dim);">SPEED</label>
        <input type="range" id="hqSpeedSlider" min="0.2" max="3" step="0.1" value="1" style="width:70px;accent-color:var(--accent);">
        <button class="btn" onclick="hqReset()" style="padding:5px 10px;font-size:10px;">‚Ü∫</button>
      </div>

      <!-- Progress track -->
      <div style="display:flex;gap:0;margin-bottom:16px;border:1px solid var(--border);border-radius:3px;overflow:hidden;font-family:'Space Mono',monospace;font-size:9px;">
        <div id="hqT0" class="sc-track active-track" style="flex:1;text-align:center;padding:5px 0;cursor:pointer;" onclick="hqGoPhase(0)">1 ¬∑ He‚ÇÉ ROOTS</div>
        <div id="hqT1" class="sc-track" style="flex:1;text-align:center;padding:5px 0;cursor:pointer;" onclick="hqGoPhase(1)">2 ¬∑ D1Q3</div>
        <div id="hqT2" class="sc-track" style="flex:1;text-align:center;padding:5px 0;cursor:pointer;" onclick="hqGoPhase(2)">3 ¬∑ ‚äó D2Q9</div>
        <div id="hqT3" class="sc-track" style="flex:1;text-align:center;padding:5px 0;cursor:pointer;" onclick="hqGoPhase(3)">4 ¬∑ ‚äó D3Q27</div>
      </div>

      <!-- Canvas + sidebar -->
      <div style="display:grid;grid-template-columns:1fr 240px;gap:20px;align-items:start;">
        <canvas id="hqCanvas" width="580" height="440"
          style="width:100%;display:block;border:1px solid var(--border);border-radius:2px;background:#070b12;">
        </canvas>
        <div style="font-family:'Space Mono',monospace;font-size:11px;line-height:1.9;color:var(--text-dim);">
          <div id="hqInfoTitle" style="color:var(--accent);font-size:10px;letter-spacing:1px;margin-bottom:8px;border-bottom:1px solid var(--border);padding-bottom:6px;">PHASE 1</div>
          <div id="hqInfoBody" style="font-size:10.5px;line-height:1.8;">Initialising...</div>
          <div id="hqInfoMath" style="margin-top:14px;border-top:1px solid var(--border);padding-top:10px;color:var(--accent2);font-size:11px;line-height:2.2;"></div>
        </div>
      </div>
    </div>

    <div class="section-nav">
      <button class="btn" onclick="goSection(1)">‚Üê The Lattice</button>
      <button class="btn primary" onclick="goSection('1b')">Next: Hermite Roots ‚Üí</button>
    </div>
  </section>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       SECTION 2: Distribution Functions
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <section class="section" id="sec2">
    <h2><span class="num">03 ¬∑ PHYSICS</span>Distribution Functions</h2>

    <p>The heart of LBM is the <strong>distribution function</strong> \(f_i(\mathbf{x},t)\) ‚Äî the discrete probability weight of finding a fluid parcel at lattice node \(\mathbf{x}\), time \(t\), carrying momentum in direction \(i\). Note that \(\sum_i f_i = \rho\), not 1; \(f_i\) is a number-density contribution, not a normalised probability.</p>

    <h3>Macroscopic Quantities</h3>
    <p>All fluid quantities are computed as <strong>moments</strong> of the distribution function:</p>

    <div class="formula">
      <span class="label">Density (zeroth moment)</span>
      $$\rho(\mathbf{x},t) = \sum_i f_i(\mathbf{x},t)$$
    </div>

    <div class="formula">
      <span class="label">Momentum (first moment)</span>
      $$\rho\,\mathbf{u}(\mathbf{x},t) = \sum_i f_i(\mathbf{x},t)\,\mathbf{e}_i$$
    </div>

    <div class="formula">
      <span class="label">Momentum flux tensor (second moment)</span>
      $$\Pi^{\alpha\beta} = \sum_i f_i\, e_i^\alpha\, e_i^\beta$$
    </div>
    <p style="font-size:0.9em;color:var(--text-dim);">Its non-equilibrium part \(\Pi^{\alpha\beta}_{\mathrm{neq}}\) drives viscous dissipation and appears in advanced collision operators (e.g. Regularised LBM in ¬ß06).</p>

    <h3>Equilibrium Distribution</h3>
    <p>LBM uses the <strong>Maxwell-Boltzmann equilibrium</strong> truncated at second order in the <em>flow velocity</em> \(\mathbf{u}\) ‚Äî i.e. at \(O(Ma^2)\) ‚Äî valid when \(Ma \ll 1\):</p>

    <div class="formula">
      <span class="label">Local Equilibrium Distribution</span>
      $$f_i^{\mathrm{eq}} = w_i\,\rho\left[1 + \frac{\mathbf{e}_i\cdot\mathbf{u}}{c_s^2} + \frac{(\mathbf{e}_i\cdot\mathbf{u})^2}{2c_s^4} - \frac{u^2}{2c_s^2}\right]$$
    </div>

    <p>where \(c_s = 1/\sqrt{3}\) is the lattice speed of sound (fixed by the Gauss&ndash;Hermite quadrature nodes, as introduced in ¬ß02). This is the distribution the system <em>relaxes toward</em> during collisions.</p>

    <h3>The BGK Collision Operator</h3>
    <p>The most widely used collision model is the <strong>Bhatnagar-Gross-Krook (BGK)</strong> approximation ‚Äî a single-relaxation-time scheme:</p>

    <div class="formula">
      <span class="label">BGK Collision operator</span>
      $$\Omega_i = -\frac{f_i - f_i^{\mathrm{eq}}}{\tau}$$
    </div>

    <p>In lattice units (\(\Delta t=1\)) the discrete update is \(f_i^* = f_i - \tfrac{1}{\tau}[f_i - f_i^\mathrm{eq}]\) (shown in ¬ß04). Here \(\tau\) is the dimensionless LBM relaxation parameter that controls the rate of return to equilibrium and determines the kinematic viscosity:</p>

    <div class="formula">
      $$\nu = c_s^2\!\left(\tau - \tfrac{1}{2}\right)\!\Delta t \;\xrightarrow{\,\Delta x=\Delta t=1\,}\; \tfrac{1}{3}\!\left(\tau - \tfrac{1}{2}\right)$$
    </div>
    <p style="font-size:0.88em; color:var(--text-dim); margin-top:4px;">The simplified form \(\nu = \tfrac{1}{3}(\tau-\tfrac{1}{2})\) holds in <strong>lattice units</strong>, where \(\Delta x = 1\) and \(\Delta t = 1\) by convention. To recover physical viscosity: \(\nu_\text{phys} = \nu_\text{lu}\,\Delta x^2/\Delta t\).</p>

    <div class="info-box" data-label="Physical Intuition">
      <p style="margin:0">Think of \(\tau\) as the "memory" of the fluid. Large \(\tau\) gives high viscosity (slow, laminar flow). As \(\tau \to 0.5\) from above, viscosity vanishes: \(\nu = \tfrac{1}{3}(\tau - \tfrac{1}{2}) \to 0\). At exactly \(\tau = 0.5\) the BGK collision operator becomes singular and the simulation diverges immediately &mdash; in practice \(\tau\) must always be <em>strictly greater than 0.5</em>.</p>
    </div>

    <div class="info-box" data-label="Why does BGK recover Navier-Stokes? ‚Äî Chapman-Enskog">
      <p style="margin:0 0 10px 0">The connection between the mesoscopic BGK equation and the macroscopic Navier-Stokes equations is established by the <strong>Chapman-Enskog expansion</strong>: expand \(f_i\) in powers of the Knudsen number \(Kn\):</p>
      <div style="text-align:center;margin:8px 0;">\[f_i = f_i^{(0)} + Kn\,f_i^{(1)} + Kn^2 f_i^{(2)} + \cdots\]</div>
      <p style="margin:4px 0">Inserting into the BGK equation and collecting powers of \(Kn\):</p>
      <ul style="margin:6px 0 6px 18px;padding:0;font-size:0.9em;">
        <li style="margin-bottom:5px;"><strong>Order \(Kn^0\):</strong> \(f_i^{(0)} = f_i^{\mathrm{eq}}\) ‚Äî zeroth order is local equilibrium.</li>
        <li style="margin-bottom:5px;"><strong>Order \(Kn^1\):</strong> yields the <em>Euler equations</em> (inviscid, no dissipation).</li>
        <li><strong>Order \(Kn^2\):</strong> the first non-equilibrium correction \(f_i^{(1)}\) contributes a viscous stress \(\boldsymbol{\sigma} = -\rho\nu(\nabla\mathbf{u}+\nabla\mathbf{u}^T)\) with \(\nu = c_s^2(\tau-\tfrac{1}{2})\Delta t\) ‚Äî recovering the <strong>incompressible Navier-Stokes equations</strong> at \(O(Ma^2)\).</li>
      </ul>
      <p style="margin:8px 0 0 0;font-size:0.88em;color:var(--text-dim);">This is why \(\tau\) controls viscosity, and why the method is only valid for \(Ma \ll 1\): higher-order expansion terms produce \(O(Ma^3)\) errors in the momentum equation.</p>
    </div>
      <div class="quiz-feedback" id="quizFeedback2"></div>
    </div>

    <div class="section-nav">
      <button class="btn" onclick="goSection(1)">‚Üê The Lattice</button>
      <button class="btn primary" onclick="goSection(3)">Next: Algorithm ‚Üí</button>
    </div>
  </section>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       SECTION 3: Algorithm
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <section class="section" id="sec3">
    <h2><span class="num">04 ¬∑ ALGORITHM</span>The LBM Loop</h2>

    <p>Each timestep consists of <strong>two core operations</strong> ‚Äî collision and streaming ‚Äî plus boundary handling and a macroscopic update:</p>

    <ol class="step-list">
      <li>
        <span class="step-num"></span>
        <div>
          <strong style="color:var(--accent)">Collision Step</strong>
          <p>At each node, the distributions are relaxed toward equilibrium. Using BGK:</p>
          <div class="formula">$$f_i^*(\mathbf{x},t) = f_i - \tfrac{1}{\tau}\bigl[f_i - f_i^{\mathrm{eq}}(\rho,\mathbf{u})\bigr]$$</div>
          <p>This is a <em>local</em> operation ‚Äî only data from the same node is needed. Perfect for parallelism.</p>
        </div>
      </li>
      <li>
        <span class="step-num"></span>
        <div>
          <strong style="color:var(--accent)">Streaming Step</strong>
          <p>Post-collision distributions are propagated to neighboring nodes along their velocity direction:</p>
          <div class="formula">$$f_i(\mathbf{x}+\mathbf{e}_i\Delta t,\,t+\Delta t) = f_i^*(\mathbf{x},t)$$</div>
          <p>This is also local ‚Äî each node propagates to its (up to) 8 neighbors, while the rest population \(f_0\) stays at the same node. The simplicity here is what makes LBM so parallelizable.</p>
        </div>
      </li>
      <li>
        <span class="step-num"></span>
        <div>
          <strong style="color:var(--accent)">Boundary Conditions</strong>
          <p>After streaming, handle boundaries. The simplest method is <em>bounce-back</em> ‚Äî particles hitting a wall are reflected opposite:</p>
          <div class="formula">$$f_{\bar{i}}(\mathbf{x}_f,\,t+1) = f_i^*(\mathbf{x}_f,\,t)$$</div>
          <p style="font-size:0.85em;color:var(--text-dim);margin-top:4px;">\(\mathbf{x}_f\) is the fluid node adjacent to the wall; \(\bar{i}\) is the opposite direction. The physical wall sits midway between the fluid node and the solid node, placing it at the correct geometric boundary (half-way bounce-back, 2nd-order accurate).</p>
          <p>Moving walls add a momentum correction proportional to \(\mathbf{u}_w\) to impart the correct tangential stress to the fluid.</p>
        </div>
      </li>
      <li>
        <span class="step-num"></span>
        <div>
          <strong style="color:var(--accent)">Macroscopic Update</strong>
          <p>Compute œÅ and <strong>u</strong> from the moments of the new distribution. These are the observable quantities ‚Äî density and velocity fields ‚Äî that can be visualized or analyzed.</p>
          <div class="formula">$$\rho = \sum_i f_i \qquad \mathbf{u} = \frac{1}{\rho}\sum_i f_i\,\mathbf{e}_i$$</div>
        </div>
      </li>
    </ol>

    <h3>Stability Criterion</h3>
    <p>Two conditions must hold simultaneously. First, \(Ma = |\mathbf{u}|/c_s \ll 1\) ‚Äî for BGK a practical limit is \(Ma \lesssim 0.1\text{‚Äì}0.15\); advanced collision operators (RLBM, CLBM, ¬ß06) tolerate somewhat higher values. Second, \(\tau > 0.5\) strictly (¬ß03) ‚Äî at \(\tau = 0.5\) viscosity vanishes and the BGK operator is singular. High-Re flow requires small \(\nu\) (small \(\tau\)) and significant lid velocity, both pushing toward instability; choosing the right collision operator is the key practical lever.</p>

    <h3>From Physics to Lattice Units</h3>
    <p>Every LBM simulation lives in <em>lattice units</em> where \(\Delta x = 1\) and \(\Delta t = 1\) by definition. Translating a physical problem requires choosing three conversion factors ‚Äî length, time, mass ‚Äî that map physical quantities to the dimensionless lattice world and back. The key invariant is the Reynolds number, which must be identical in both worlds.</p>

    <div class="info-box" data-label="Unit Conversion Recipe">
      <p style="margin:0 0 10px 0">Given a physical problem with characteristic length \(L_\text{phys}\), velocity \(U_\text{phys}\), kinematic viscosity \(\nu_\text{phys}\):</p>
      <ol style="margin:0 0 10px 18px;padding:0;">
        <li style="margin-bottom:7px;"><strong>Choose resolution:</strong> assign \(N\) lattice nodes to \(L_\text{phys}\), giving \(\Delta x = L_\text{phys}/N\).</li>
        <li style="margin-bottom:7px;"><strong>Choose lattice velocity:</strong> pick \(u_\text{lu} \lesssim 0.1\) (Ma constraint). Then \(\Delta t = (u_\text{lu}/U_\text{phys})\,\Delta x\).</li>
        <li style="margin-bottom:7px;"><strong>Compute \(\tau\):</strong> \(\nu_\text{lu} = \nu_\text{phys}\,\Delta t/\Delta x^2\), then \(\tau = 3\nu_\text{lu} + \tfrac{1}{2}\). Verify \(\tau > 0.5\).</li>
        <li><strong>Verify Re:</strong> \(Re_\text{lu} = u_\text{lu}\,N/\nu_\text{lu}\) must equal \(Re_\text{phys} = U_\text{phys}\,L_\text{phys}/\nu_\text{phys}\).</li>
      </ol>
      <p style="margin:0;font-size:0.88em;color:var(--text-dim);">A fully worked example applying this recipe to the K√°rm√°n vortex street is given in ¬ß07.</p>
    </div>

    <div class="section-nav">
      <button class="btn" onclick="goSection(2)">‚Üê Distributions</button>
      <button class="btn primary" onclick="goSection(4)">Next: Stream &amp; Collide ‚Üí</button>
    </div>
  </section>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       SECTION 4: Interactive Streaming & Collision
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <section class="section" id="sec4">
    <h2><span class="num">05 ¬∑ INTERACTIVE</span>Streaming &amp; Collision Step by Step</h2>

    <p>Two complementary visualizations of the same process: first watch distributions flow continuously across the lattice, then step through a single timestep cell-by-cell to see exactly what changes at each phase.</p>

    <!-- ‚îÄ‚îÄ Flying-bullet streaming visualisation ‚îÄ‚îÄ -->
    <h3 style="margin:32px 0 8px;">Part 1 ‚Äî Streaming Animation</h3>
    <p style="margin:0 0 16px;color:var(--text-dim);font-size:0.92em;">Watch distribution packets travel across the lattice in real time. Each coloured bullet is one f<sub>i</sub> value moving to its neighbour. Click any node to highlight its outgoing streams.</p>
    <div style="background:var(--surface);border:1px solid var(--border);border-radius:4px;padding:20px 24px;margin-bottom:24px;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:14px;flex-wrap:wrap;gap:10px;">
        <span style="font-family:'Space Mono',monospace;font-size:11px;letter-spacing:2px;color:var(--accent);text-transform:uppercase;">‚ñ∂ Streaming Animation ‚Äî distributions in flight</span>
        <div style="display:flex;gap:8px;align-items:center;">
          <button class="btn" id="flyPauseBtn" onclick="flyToggle()" style="padding:5px 12px;font-size:10px;">‚ñ† PAUSE</button>
          <label style="font-family:'Space Mono',monospace;font-size:10px;color:var(--text-dim);">SPEED</label>
          <input type="range" id="flySpeedSlider" min="0.3" max="3" step="0.1" value="1" style="width:80px;accent-color:var(--accent);">
        </div>
      </div>
      <div style="display:grid;grid-template-columns:1fr auto;gap:16px;align-items:center;">
        <canvas id="flyCanvas" width="560" height="560" style="width:100%;max-width:560px;display:block;border:1px solid var(--border);border-radius:2px;background:#06090e;cursor:pointer;" onclick="flyClickNode(event)"></canvas>
        <div id="flyInfoPanel" style="min-width:160px;font-family:'Space Mono',monospace;font-size:11px;line-height:2;color:var(--text-dim);">
          <div style="color:var(--accent);letter-spacing:1px;margin-bottom:8px;font-size:10px;">ACTIVE NODE</div>
          <div>Node: <span id="flyNodeLabel" style="color:var(--accent)">‚Äî</span></div>
          <div>œÅ = <span id="flyRho" style="color:var(--text)">‚Äî</span></div>
          <div>u‚Çì = <span id="flyUx" style="color:var(--accent2)">‚Äî</span></div>
          <div>u·µß = <span id="flyUy" style="color:var(--accent2)">‚Äî</span></div>
          <div style="margin-top:10px;color:var(--accent);letter-spacing:1px;font-size:10px;">IN FLIGHT</div>
          <div id="flyInFlight" style="margin-top:4px;line-height:1.9;"></div>
          <div style="margin-top:12px;color:var(--text-dim);font-size:10px;line-height:1.6;">Click any node<br>to highlight its<br>outgoing streams</div>
        </div>
      </div>
      <div style="margin-top:10px;display:flex;gap:20px;flex-wrap:wrap;font-family:'Space Mono',monospace;font-size:10px;color:var(--text-dim);">
        <span>Bullet colour = f·µ¢ magnitude: <span style="background:linear-gradient(90deg,#0000ff,#00ffff,#00ff00,#ffff00,#ff0000);padding:1px 22px;border-radius:2px;">&nbsp;</span> low‚Üíhigh</span>
        <span>Bullet size ‚àù f·µ¢ value</span>
        <span>Each wave = one streaming timestep</span>
      </div>
    </div>

    <!-- ‚îÄ‚îÄ Step-by-step section ‚îÄ‚îÄ -->
    <h3 style="margin:40px 0 8px;">Part 2 ‚Äî Step-by-Step Walkthrough</h3>
    <p style="margin:0 0 20px;color:var(--text-dim);font-size:0.92em;">Step through a single LBM timestep manually on a 7√ó7 lattice. Use <strong>NEXT STEP ‚Üí</strong> to advance through each phase. Click any cell to inspect its distribution values and see exactly what changes during streaming and collision.</p>

    <!-- ‚îÄ‚îÄ Step controls ‚îÄ‚îÄ -->
    <div style="display:flex;gap:12px;margin:0 0 16px;flex-wrap:wrap;align-items:center;">
      <span style="font-family:'Space Mono',monospace;font-size:11px;color:var(--text-dim);letter-spacing:1px;">PHASE:</span>
      <span id="scPhasePill" style="font-family:'Space Mono',monospace;font-size:12px;padding:6px 18px;border:1px solid var(--accent);color:var(--accent);border-radius:2px;background:var(--highlight);white-space:nowrap;">INITIAL STATE</span>
      <div style="flex:1;min-width:12px;"></div>
      <button class="btn" onclick="scPrev()" id="scPrevBtn" disabled>‚Üê PREV</button>
      <button class="btn primary" onclick="scNext()" id="scNextBtn">NEXT STEP ‚Üí</button>
      <button class="btn" onclick="scReset()">‚Ü∫ RESET</button>
    </div>

    <!-- ‚îÄ‚îÄ Progress track ‚îÄ‚îÄ -->
    <div style="display:flex;gap:0;margin-bottom:20px;border:1px solid var(--border);border-radius:3px;overflow:hidden;font-family:'Space Mono',monospace;font-size:10px;">
      <div id="scTrack0" class="sc-track active-track" onclick="scGoPhase(0)">INITIAL</div>
      <div id="scTrack1" class="sc-track" onclick="scGoPhase(1)">STREAM ARROWS</div>
      <div id="scTrack2" class="sc-track" onclick="scGoPhase(2)">POST-STREAM</div>
      <div id="scTrack3" class="sc-track" onclick="scGoPhase(3)">COLLISION Œî</div>
      <div id="scTrack4" class="sc-track" onclick="scGoPhase(4)">POST-COLLISION</div>
    </div>

    <!-- ‚îÄ‚îÄ Explanation box ‚îÄ‚îÄ -->
    <div class="info-box" data-label="What's happening" style="margin-bottom:20px;min-height:72px;">
      <p id="scExplainText" style="margin:0;font-size:0.95rem;line-height:1.6;"></p>
    </div>

    <!-- ‚îÄ‚îÄ œÑ slider ‚îÄ‚îÄ -->
    <div style="display:flex;gap:20px;align-items:center;margin-bottom:20px;flex-wrap:wrap;">
      <div class="param-group" style="flex-direction:row;align-items:center;gap:12px;">
        <label style="white-space:nowrap;">Relaxation œÑ</label>
        <input type="range" id="scTauSlider" min="0.6" max="2.0" step="0.1" value="0.9" oninput="scChangeTau(this.value)" style="width:120px;accent-color:var(--accent)">
        <span class="param-val" id="scTauVal">œÑ = 0.9</span>
      </div>
      <div style="font-family:'Space Mono',monospace;font-size:11px;color:var(--text-dim);">
        ŒΩ = <span id="scNuVal" style="color:var(--accent2)">0.133</span> &nbsp;|&nbsp; œâ = 1/œÑ = <span id="scOmegaVal" style="color:var(--accent2)">1.111</span>
      </div>
    </div>

    <!-- ‚îÄ‚îÄ Main layout: canvas + detail side by side ‚îÄ‚îÄ -->
    <div style="display:grid;grid-template-columns:1fr 320px;gap:20px;align-items:start;" id="scMainLayout">

      <!-- Grid canvas -->
      <div style="position:relative;">
        <canvas id="scCanvas" width="630" height="630" style="width:100%;border:1px solid var(--border);cursor:pointer;display:block;"></canvas>
        <div id="scAnimOverlay" style="position:absolute;inset:0;pointer-events:none;"></div>
      </div>

      <!-- Side panel -->
      <div id="scSidePanel" style="position:sticky;top:20px;">
        <div style="font-family:'Space Mono',monospace;font-size:11px;color:var(--accent);letter-spacing:2px;margin-bottom:12px;text-transform:uppercase;">
          Selected Cell <span id="scSelLabel" style="color:var(--text-dim)">(click a cell)</span>
        </div>

        <!-- 3√ó3 f-value mini grid -->
        <div id="scFGrid" style="display:grid;grid-template-columns:repeat(3,1fr);gap:3px;margin-bottom:14px;"></div>

        <!-- Macroscopic values -->
        <div style="background:var(--surface);border:1px solid var(--border);padding:12px;font-family:'Space Mono',monospace;font-size:12px;line-height:2;border-radius:2px;margin-bottom:14px;">
          <div>œÅ&nbsp;=&nbsp;<span id="scRhoVal" style="color:var(--accent)">‚Äî</span></div>
          <div>u‚Çì =&nbsp;<span id="scUxVal" style="color:var(--accent2)">‚Äî</span></div>
          <div>u·µß =&nbsp;<span id="scUyVal" style="color:var(--accent2)">‚Äî</span></div>
        </div>

        <!-- Source-highlight explainer (streaming phase) -->
        <div id="scSourceNote" style="display:none;background:rgba(0,212,255,0.06);border:1px solid rgba(0,212,255,0.3);border-radius:2px;padding:10px 12px;font-size:13px;font-family:'Space Mono',monospace;color:var(--text-dim);line-height:1.7;"></div>

        <!-- Collision detail (collision phase) -->
        <div id="scCollNote" style="display:none;background:rgba(255,107,53,0.06);border:1px solid rgba(255,107,53,0.3);border-radius:2px;padding:10px 12px;font-size:12px;font-family:'Space Mono',monospace;color:var(--text-dim);line-height:1.7;"></div>
      </div>
    </div>

    <!-- Legend -->
    <div style="display:flex;gap:24px;margin-top:16px;flex-wrap:wrap;font-family:'Space Mono',monospace;font-size:11px;color:var(--text-dim);">
      <span>‚ñ† <span style="color:var(--accent)">cyan</span> = f closer to max</span>
      <span>‚ñ† <span style="color:#1a3a5a">dark</span> = f near zero</span>
      <span>‚ñ† <span style="color:#39ff14">green overlay</span> = f increases in collision</span>
      <span>‚ñ† <span style="color:#ff4466">red overlay</span> = f decreases in collision</span>
      <span>‚ñ† arrows: <span style="background:linear-gradient(90deg,#0000ff,#00ffff,#00ff00,#ffff00,#ff0000);padding:0 18px;border-radius:2px;">&nbsp;</span> = f·µ¢ magnitude (low‚Üíhigh)</span>
    </div>

    <div class="section-nav" style="margin-top:48px;">
      <button class="btn" onclick="goSection(3)">‚Üê Algorithm</button>
      <button class="btn primary" onclick="goSection(5)">Next: Live Simulation ‚Üí</button>
    </div>
  </section>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       SECTION 4: Live Simulation
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <section class="section" id="sec5">
    <h2><span class="num">06 ¬∑ SIMULATION</span>Live LBM ‚Äî Lid-Driven Cavity</h2>

    <p>The <strong>lid-driven cavity</strong> is the "Hello World" of computational fluid dynamics. A square box of fluid with a <em>moving top wall</em> drives a characteristic vortex pattern. Watch how the vortex forms and evolves!</p>

    <div class="sim-container">
      <div class="sim-header">
        <span class="sim-title">‚ñ∂ D2Q9 LBM ‚Äî Collision Model Explorer</span>
        <div class="sim-controls">
          <button class="btn primary" id="playBtn" onclick="toggleSim()">‚ñ† PAUSE</button>
          <button class="btn" onclick="resetSim()">‚Ü∫ RESET</button>
          <button class="btn" id="modeBtn" onclick="toggleMode()">MODE: VELOCITY</button>
          <button class="btn" id="arrowBtn" onclick="toggleArrows()" style="border-color:#4ade80;color:#4ade80;">ARROWS: OFF</button>
          <button class="btn" id="modelBtn" onclick="toggleModel()" style="border-color:var(--accent2);color:var(--accent2);">MODEL: BGK</button>
        </div>
      </div>

      <div class="sim-canvas-wrap" id="lbmWrap">
        <canvas id="lbmCanvas" width="600" height="600" style="width:100%;aspect-ratio:1;display:block;border:none;border-radius:2px;"></canvas>
      </div>
      <div class="sim-resize-bar">
        <label for="lbmSizeSlider">SIZE</label>
        <input type="range" id="lbmSizeSlider" min="280" max="900" value="680" step="10"
               oninput="document.getElementById('lbmWrap').style.maxWidth=this.value+'px'">
      </div>

      <div class="param-row">
        <div class="param-group">
          <label>Relaxation œÑ</label>
          <input type="range" id="tauSlider" min="0.52"  max="2.0" step="0.001" value="0.85" oninput="updateTau(this.value)">
          <span class="param-val" id="tauVal">œÑ = 0.85</span>
        </div>
        <div class="param-group">
          <label>Lid Velocity</label>
          <input type="range" id="uSlider" min="0.01" max="0.15" step="0.005" value="0.05" oninput="updateU(this.value)">
          <span class="param-val" id="uVal">u = 0.050</span>
        </div>
        <div style="font-family:'Space Mono',monospace; font-size:11px; color:var(--text-dim); padding-top:20px;">
          Re ‚âà <span id="reVal" style="color:var(--accent)">‚Äî</span><br>
          Step: <span id="stepVal" style="color:var(--accent)">0</span>
        </div>
      </div>

      <div class="legend">
        <div class="legend-item">
          <div class="legend-swatch" style="background:linear-gradient(90deg,#000080,#0000ff,#00ffff,#00ff00,#ffff00,#ff0000)"></div>
          Velocity magnitude (low ‚Üí high)
        </div>
        <div class="legend-item">
          <div class="legend-swatch" style="background:rgba(255,255,255,0.9); border:1px solid #444"></div>
          Wall
        </div>
      </div>

      <p id="simHint" style="font-size:14px; color:var(--text-dim); margin-top:12px; font-family:'Space Mono',monospace;">
        ‚Üë <strong>BGK</strong>: simple and accurate at moderate Re, but diverges below œÑ ‚âà 0.53.
      </p>
    </div>

    <h3>What you're seeing</h3>
    <p>The color map shows <strong>velocity magnitude</strong> ‚Äî red is fast, blue is slow. The top wall moves rightward, dragging the fluid and creating a large clockwise vortex. At high Reynolds numbers (low œÑ), secondary vortices appear in the bottom corners ‚Äî a hallmark of this benchmark problem.</p>

    <p>The <strong>Reynolds number</strong> \(\mathrm{Re} = uL/\nu\) characterizes the flow regime. Below Re~400 the flow is dominated by a single primary vortex; above Re~1000 the vortex centre shifts noticeably toward the upper-right and secondary corner vortices appear ‚Äî both well documented in the Ghia et al. (1982) benchmark.</p>

    <h3>Three Collision Models</h3>
    <p>Click <strong>MODEL</strong> to cycle through BGK ‚Üí RLBM ‚Üí CLBM.</p>
    <p><strong>BGK</strong> is the simplest collision operator: all 9 populations relax toward equilibrium at the same rate \(1/\tau\). This means hydrodynamic and non-hydrodynamic (ghost) modes are damped equally ‚Äî as \(\tau\to 0.5\) ghost modes become severely under-damped and eventually overwhelm the physical solution.</p>
    <p><strong>RLBM</strong> (Latt &amp; Chopard 2006) reconstructs \(f\) from only its stress-tensor non-equilibrium part before every collision, discarding ghost modes. Stable down to œÑ = 0.501. At high œÑ (smooth flow) the ghost-mode filtering is unnecessary and shifts the \(O(Ma^3)\) truncation error relative to BGK, producing a small visible difference ‚Äî not a numerical instability, but a change in the effective discretisation error.</p>
    <p><strong>Cumulant LBM</strong> (Geier et al. 2015) performs the collision in <em>cumulant space</em>: it transforms \(f\) to raw moments ‚Üí central moments ‚Üí cumulants, relaxes each cumulant at its own rate, and transforms back. The 2nd-order cumulants (\(\kappa_{20}, \kappa_{11}, \kappa_{02}\)) relax at \(1/\tau\) (physical viscosity); the 3rd-order cumulants (\(\kappa_{21}, \kappa_{12}\)) are relaxed fully to remove cubic-velocity errors in the stress tensor; the 4th-order cumulant \(\kappa_{22}\) is relaxed to zero, correcting the Galilean invariance error inherent in BGK and RLBM. The higher-cumulant relaxation rates are tunable parameters, commonly set to 1. Best accuracy across all Re ‚Äî no artefacts, no blow-up.</p>

    <div class="section-nav">
      <button class="btn" onclick="goSection(4)">‚Üê Stream &amp; Collide</button>
      <button class="btn primary" onclick="goSection(6)">Next: K√°rm√°n Vortex ‚Üí</button>
    </div>
  </section>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       SECTION 6: K√°rm√°n Vortex Street
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <section class="section" id="sec6">
    <h2><span class="num">07 ¬∑ FLOW PAST CYLINDER</span>K√°rm√°n Vortex Street</h2>

    <p>One of the most iconic phenomena in fluid dynamics: a circular cylinder immersed in a steady uniform flow sheds alternating vortices downstream, forming the <strong>K√°rm√°n vortex street</strong>. At low Re the wake is steady; above Re ‚âà 47 the symmetry breaks and periodic vortex shedding begins.</p>

    <div class="sim-container">
      <div class="sim-header">
        <span class="sim-title">‚ñ∂ D2Q9 LBM ‚Äî Flow Past Cylinder</span>
        <div class="sim-controls">
          <button class="btn primary" id="kvPlayBtn" onclick="kvToggleSim()">‚ñ† PAUSE</button>
          <button class="btn" onclick="kvResetSim()">‚Ü∫ RESET</button>
          <button class="btn" id="kvModeBtn" onclick="kvToggleMode()">MODE: VELOCITY</button>
          <button class="btn" id="kvArrowBtn" onclick="kvToggleArrows()" style="border-color:#4ade80;color:#4ade80;">ARROWS: OFF</button>
          <button class="btn" id="kvModelBtn" onclick="kvToggleModel()" style="border-color:var(--accent2);color:var(--accent2);">MODEL: BGK</button>
        </div>
      </div>

      <div class="sim-canvas-wrap" id="kvWrap">
        <canvas id="kvCanvas" width="720" height="300" style="width:100%;display:block;border:none;border-radius:2px;"></canvas>
      </div>
      <div class="sim-resize-bar">
        <label for="kvSizeSlider">SIZE</label>
        <input type="range" id="kvSizeSlider" min="280" max="900" value="680" step="10"
               oninput="document.getElementById('kvWrap').style.maxWidth=this.value+'px'">
      </div>

      <div class="param-row">
        <div class="param-group">
          <label>Relaxation œÑ</label>
          <input type="range" id="kvTauSlider" min="0.52" max="1.5" step="0.001" value="0.56" oninput="kvUpdateTau(this.value)">
          <span class="param-val" id="kvTauVal">œÑ = 0.560</span>
        </div>
        <div class="param-group">
          <label>Inflow velocity</label>
          <input type="range" id="kvUSlider" min="0.01" max="0.15" step="0.002" value="0.07" oninput="kvUpdateU(this.value)">
          <span class="param-val" id="kvUVal">u = 0.070</span>
        </div>
        <div style="font-family:'Space Mono',monospace; font-size:11px; color:var(--text-dim); padding-top:20px;">
          Re ‚âà <span id="kvReVal" style="color:var(--accent)">‚Äî</span><br>
          Step: <span id="kvStepVal" style="color:var(--accent)">0</span>
        </div>
      </div>

      <div class="legend">
        <div class="legend-item">
          <div class="legend-swatch" style="background:linear-gradient(90deg,#000080,#0000ff,#00ffff,#00ff00,#ffff00,#ff0000)"></div>
          Velocity magnitude (low ‚Üí high)
        </div>
        <div class="legend-item">
          <div class="legend-swatch" style="background:rgba(170,178,190,0.9); border:1px solid #444"></div>
          Cylinder (periodic top/bottom)
        </div>
      </div>

      <p id="kvHint" style="font-size:14px; color:var(--text-dim); margin-top:12px; font-family:'Space Mono',monospace;">
        ‚Üë <strong>BGK</strong>: Re ‚âà 100‚Äì200 gives clear vortex shedding. Try œÑ ‚âà 0.55‚Äì0.65.
      </p>
    </div>

    <h3>What you're seeing</h3>
    <p>Flow enters from the left at a uniform velocity and wraps around the cylinder. Above a critical Reynolds number (Re ‚âà 47 for an infinitely long cylinder) the wake becomes unstable: the top and bottom shear layers alternately roll up into discrete vortices that detach and drift downstream, forming the characteristic staggered double row.</p>

    <p>The <strong>Strouhal number</strong> \(St = f D / U\) measures the dimensionless vortex shedding rate. For a circular cylinder \(St \approx 0.2\) over a wide Re range. Switch to <strong>VORTICITY</strong> mode ‚Äî the alternating red/blue patches in the wake are individual vortex cores: red = clockwise, blue = counter-clockwise rotation.</p>

    <h3>Worked Example: Physical ‚Üî Lattice Units</h3>
    <p>This simulation uses 360 √ó 150 nodes with a cylinder of diameter \(D = 26\) lattice nodes. To model a <strong>1 cm cylinder in water</strong> (\(\nu = 10^{-6}\,\text{m}^2/\text{s}\)) at Re = 100, the slider values map to physical reality as follows:</p>

    <div class="info-box" data-label="Worked Example ‚Äî K√°rm√°n Vortex Street at Re = 100">
      <p style="margin:0 0 8px 0"><strong>Given:</strong> \(D_\text{phys} = 0.01\,\text{m}\), \(\nu_\text{phys} = 10^{-6}\,\text{m}^2/\text{s}\), target \(Re = 100\), grid \(D_\text{lu} = 26\) nodes.</p>

      <p style="margin:6px 0 2px 0"><strong>‚ë† Length scale:</strong></p>
      <div style="text-align:center;margin:4px 0 8px;">\[\Delta x = \frac{D_\text{phys}}{D_\text{lu}} = \frac{0.01\,\text{m}}{26} \approx 385\,\mu\text{m per node}\]</div>

      <p style="margin:6px 0 2px 0"><strong>‚ë° Physical velocity</strong> from Re, then lattice velocity (choose \(u_\text{lu} = 0.07\)):</p>
      <div style="text-align:center;margin:4px 0 8px;">\[U_\text{phys} = \frac{Re\cdot\nu_\text{phys}}{D_\text{phys}} = \frac{100\times10^{-6}}{0.01} = 0.01\,\text{m/s}, \qquad \Delta t = \frac{u_\text{lu}}{U_\text{phys}}\Delta x = \frac{0.07}{0.01}\times385\,\mu\text{m} \approx 2.7\,\text{ms per step}\]</div>

      <p style="margin:6px 0 2px 0"><strong>‚ë¢ Lattice viscosity and \(\tau\):</strong></p>
      <div style="text-align:center;margin:4px 0 8px;">\[\nu_\text{lu} = \nu_\text{phys}\frac{\Delta t}{\Delta x^2} = 10^{-6}\times\frac{2.7\times10^{-3}}{(3.85\times10^{-4})^2} \approx 0.0182, \qquad \tau = 3\nu_\text{lu}+\tfrac{1}{2} \approx 0.555\]</div>

      <p style="margin:6px 0 2px 0"><strong>‚ë£ Verify Re is preserved:</strong></p>
      <div style="text-align:center;margin:4px 0 8px;">\[Re_\text{lu} = \frac{u_\text{lu}\cdot D_\text{lu}}{\nu_\text{lu}} = \frac{0.07\times26}{0.0182} \approx 100\;\checkmark\]</div>

      <p style="margin:4px 0 0 0;font-size:0.88em;color:var(--text-dim);">Each lattice step ‚âà 2.7 ms of physical time. The sliders at \(\tau \approx 0.56\), \(u \approx 0.07\) match exactly this physical setup. Doubling the grid resolution (\(D_\text{lu}=52\)) would halve \(\Delta x\), require a new \(\Delta t\) and \(\tau\), but keep Re = 100 identical.</p>
    </div>

    <div class="section-nav">
      <button class="btn" onclick="goSection(5)">‚Üê Lid-Driven Cavity</button>
      <button class="btn primary" onclick="goSection(7)">Next: Applications ‚Üí</button>
    </div>
  </section>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       SECTION 5: Applications
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <section class="section" id="sec8">
    <h2><span class="num">08 ¬∑ APPLICATIONS</span>Where LBM Shines</h2>

    <p>LBM has become a go-to method for a remarkably diverse range of problems, particularly those where traditional CFD methods struggle.</p>

    <div class="two-col">
      <div class="info-box" data-label="Porous Media Flow">
        <p style="margin:0">LBM handles complex pore geometries naturally ‚Äî just mark voxels as solid or fluid. Used extensively in <strong>oil reservoir simulation</strong>, filter design, and geological flow studies.</p>
      </div>
      <div class="info-box" data-label="Multiphase Flows">
        <p style="margin:0">The <strong>Shan-Chen</strong> model adds inter-particle forces to simulate droplets, bubbles, and phase separation ‚Äî including surface tension and contact angles on surfaces.</p>
      </div>
      <div class="info-box" data-label="Turbulence">
        <p style="margin:0">LBM scales efficiently on GPUs, making it competitive for <strong>DNS and LES</strong> of turbulent flows. Some of the largest LBM simulations run at Petaflop scales.</p>
      </div>
      <div class="info-box" data-label="Microfluidics & Bio">
        <p style="margin:0">At micro/nano scales, LBM naturally captures <strong>slip flow</strong> and Knudsen effects. Used for blood cell dynamics, drug delivery, and lab-on-chip device design.</p>
      </div>
    </div>

    <h3>Extensions of the Basic Method</h3>

    <p><strong>Multiple Relaxation Time (MRT)</strong> ‚Äî instead of a single œÑ, each moment of the distribution relaxes at its own rate. By relaxing non-hydrodynamic (ghost) modes faster than hydrodynamic ones, MRT suppresses the under-damping that destabilises BGK at small œÑ, without altering the physical viscosity.</p>

    <p><strong>Regularised LBM</strong> (Latt &amp; Chopard 2006) ‚Äî reconstructs \(f\) from only its stress-tensor non-equilibrium component before each collision (see ¬ß06 for details). Simple, parameter-free, stable for any \(\tau &gt; 0.5\).</p>
    <p><strong>Cumulant LBM</strong> (Geier, Sch√∂nherr, Pasquali &amp; Krafczyk, 2015) ‚Äî collides in cumulant space, where each statistical mode can be relaxed independently. The 4th-order cumulant \(\kappa_{22}\) is relaxed to zero, removing the Galilean invariance violation inherent in BGK and MRT. State of the art for turbulence DNS.</p>
    <p><strong>Entropic LBM (ELBM) &amp; KBC</strong> ‚Äî enforce the discrete H-theorem at every node. The <strong>KBC model</strong> (Karlin, B√∂sch &amp; Chikatamarla, 2014) decomposes \(f\) into shear and ghost modes, choosing the ghost damping rate entropically ‚Äî unconditionally stable in the sense of the discrete H-theorem and without added diffusivity, though physical accuracy still requires adequate grid resolution.</p>


    <p><strong>Thermal LBM</strong> ‚Äî couples a second distribution function for energy transport, enabling simulation of heat convection and natural convection flows.</p>

    <h3>Software Ecosystem</h3>
    <p>Major LBM frameworks include <strong>OpenLB</strong>, <strong>Palabos</strong> (open-source, C++), <strong>waLBerla</strong> (massively parallel), and <strong>PowerFLOW</strong> (commercial, used in aerospace/automotive). GPU-native solvers like <strong>FluidX3D</strong> enable interactive-speed simulations on consumer hardware.</p>

    <div class="highlight-box">
      <p style="margin:0; font-size:1rem;"><strong>Further Reading:</strong> S. Succi, <em>The Lattice Boltzmann Equation: For Complex States of Flowing Matter</em> (2018) ‚Äî the definitive modern reference. For a quick start, see Kr√ºger et al., <em>The Lattice Boltzmann Method: Principles and Practice</em> (Springer, 2017).</p>
    </div>

    <div class="section-nav">
      <button class="btn" onclick="goSection(5)">‚Üê Live Simulation</button>
      <button class="btn primary" onclick="goSection(7)">Next: Semi-Lagrangian ‚Üí</button>
    </div>
  </section>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       SECTION 7: Semi-Lagrangian LBM
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <section class="section" id="sec7">
    <h2><span class="num">09 ¬∑ SEMI-LAGRANGIAN</span>LBM on Unstructured Grids</h2>

    <p style="font-size:0.88em;color:var(--text-dim);margin-bottom:1rem;"><em>Note on quadrature terminology:</em> ¬ß01&ndash;02 used <strong>Gauss&ndash;Hermite</strong> quadrature to discretise <em>velocity space</em> into the D2Q9 lattice. This section uses a completely separate quadrature ‚Äî <strong>Gauss&ndash;Lobatto</strong> nodes ‚Äî to interpolate \(f\) in <em>physical space</em> within each mesh cell. The two are unrelated.</p>

    <p>The classical LBM is tied to a <strong>regular Cartesian grid</strong> ‚Äî streaming moves populations exactly one lattice spacing per step. The <strong>Semi-Lagrangian LBM</strong> (Kr√§mer et al., 2017) breaks this constraint, enabling LBM on fully unstructured meshes while preserving its algorithmic simplicity.</p>

    <div class="two-col" style="margin-bottom:1.5rem;">
      <div class="info-box" data-label="Key Idea">
        <p style="margin:0">Instead of streaming along fixed links, we ask: <em>where did the population f<sub>q</sub> at node <strong>x</strong><sub>A</sub> come from?</em> Tracing backwards along the characteristic gives a <strong>departure point</strong> x<sub>D</sub> = x<sub>A</sub> ‚àí <strong>e</strong><sub>q</sub>¬∑Œît, which lies somewhere inside a mesh cell.</p>
      </div>
      <div class="info-box" data-label="Why Unstructured?">
        <p style="margin:0">Unstructured grids adapt to complex geometries ‚Äî fine near boundaries, coarse in the bulk. LBM's simplicity is preserved: no Poisson solve, no flux integrals, just <strong>interpolate ‚Üí stream ‚Üí collide</strong>.</p>
      </div>
    </div>

    <h3>The Algorithm ‚Äî Three Steps</h3>
    <p>For each node x<sub>A</sub> and each velocity direction <strong>e</strong><sub>q</sub>:</p>
    <ol style="line-height:2.2;font-size:1rem;">
      <li><strong>Find</strong> the departure point x<sub>D</sub> = x<sub>A</sub> ‚àí <strong>e</strong><sub>q</sub>¬∑Œît by tracing the characteristic backwards</li>
      <li><strong>Locate</strong> the mesh cell containing x<sub>D</sub>, then <strong>interpolate</strong> f<sub>q</sub>(x<sub>D</sub>) using a high-order polynomial reconstruction at Gauss‚ÄìLobatto‚ÄìChebyshev nodes</li>
      <li><strong>Stream</strong>: assign f<sub>q</sub>(x<sub>A</sub>) ‚Üê f<sub>q</sub>(x<sub>D</sub>), then apply BGK <strong>collision</strong></li>
    </ol>

    <h3>Interactive Visualisation</h3>
    <p>The animation below shows a single quad cell with <strong>5√ó5 Gauss‚ÄìLobatto‚ÄìChebyshev support nodes</strong> (4th-order accurate: the interpolant is exact for polynomials of degree ‚â§ 4). Watch how the departure point is found, how the polynomial surface is reconstructed, and how the interpolated value streams to the arrival node.</p>

    <!-- Canvas container -->
    <div style="background:var(--surface);border:1px solid var(--border);border-radius:6px;padding:20px 24px;margin-bottom:24px;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:14px;flex-wrap:wrap;gap:10px;">
        <span id="slbmPhaseLabel" style="font-family:'Space Mono',monospace;font-size:12px;letter-spacing:2px;color:var(--accent);text-transform:uppercase;">‚Äî SEMI-LAGRANGIAN LBM ‚Äî</span>
        <div style="display:flex;gap:8px;align-items:center;">
          <button class="btn" id="slbmPauseBtn" onclick="slbmToggle()" style="padding:5px 14px;font-size:10px;">‚ñ† PAUSE</button>
          <label style="font-family:'Space Mono',monospace;font-size:10px;color:var(--text-dim);">SPEED</label>
          <input type="range" id="slbmSpeedSlider" min="0.2" max="2.5" step="0.1" value="1" style="width:80px;accent-color:var(--accent);">
        </div>
      </div>
      <div class="slbm-grid">
        <div class="sim-canvas-wrap" id="slbmWrap">
          <canvas id="slbmCanvas" width="580" height="520" style="width:100%;display:block;border:none;border-radius:3px;background:#070b12;"></canvas>
        </div>
        <div class="sim-resize-bar">
          <label for="slbmSizeSlider">SIZE</label>
          <input type="range" id="slbmSizeSlider" min="280" max="900" value="680" step="10"
                 oninput="document.getElementById('slbmWrap').style.maxWidth=this.value+'px'">
        </div>
        <div style="font-family:'Space Mono',monospace;font-size:11px;line-height:1.9;color:var(--text-dim);">
          <div id="slbmStepTitle" style="color:var(--accent);font-size:12px;letter-spacing:1px;margin-bottom:10px;border-bottom:1px solid var(--border);padding-bottom:8px;">STEP 1</div>
          <div id="slbmStepDesc" style="font-size:10.5px;line-height:1.8;color:var(--text);">Initialising...</div>
          <div style="margin-top:16px;border-top:1px solid var(--border);padding-top:12px;">
            <div style="color:var(--accent);font-size:10px;letter-spacing:1px;margin-bottom:6px;">MATH</div>
            <div id="slbmMath" style="font-size:11px;color:var(--accent2);line-height:2.0;"></div>
          </div>
          <div style="margin-top:16px;border-top:1px solid var(--border);padding-top:12px;font-size:10px;color:var(--text-dim);line-height:1.7;">
            <div style="margin-bottom:4px;">‚óè Arrival node x<sub style="font-size:9px">A</sub></div>
            <div style="margin-bottom:4px;color:#f97316;">‚üµ Characteristic e<sub style="font-size:9px">1</sub>¬∑Œît</div>
            <div style="margin-bottom:4px;color:#a78bfa;">‚ú¶ Departure point x<sub style="font-size:9px">D</sub></div>
            <div style="margin-bottom:4px;color:#34d399;">‚óè GL-Chebyshev nodes</div>
            <div style="color:#f59e0b;">‚Üó Streaming f* ‚Üí x<sub style="font-size:9px">A</sub></div>
          </div>
        </div>
      </div>
      <!-- Step progress bar -->
      <div style="display:flex;gap:0;margin-top:14px;border:1px solid var(--border);border-radius:3px;overflow:hidden;font-family:'Space Mono',monospace;font-size:9px;">
        <div id="slbmT0" class="sc-track active-track" style="flex:1;text-align:center;padding:5px 0;cursor:pointer;" onclick="slbmGoPhase(0)">0 ¬∑ D2Q9</div>
        <div id="slbmT1" class="sc-track" style="flex:1;text-align:center;padding:5px 0;cursor:pointer;" onclick="slbmGoPhase(1)">1 ¬∑ MESH</div>
        <div id="slbmT2" class="sc-track" style="flex:1;text-align:center;padding:5px 0;cursor:pointer;" onclick="slbmGoPhase(2)">2 ¬∑ DEPARTURE</div>
        <div id="slbmT3" class="sc-track" style="flex:1;text-align:center;padding:5px 0;cursor:pointer;" onclick="slbmGoPhase(3)">3 ¬∑ ZOOM</div>
        <div id="slbmT4" class="sc-track" style="flex:1;text-align:center;padding:5px 0;cursor:pointer;" onclick="slbmGoPhase(4)">4 ¬∑ GL NODES</div>
        <div id="slbmT5" class="sc-track" style="flex:1;text-align:center;padding:5px 0;cursor:pointer;" onclick="slbmGoPhase(5)">5 ¬∑ INTERP</div>
        <div id="slbmT6" class="sc-track" style="flex:1;text-align:center;padding:5px 0;cursor:pointer;" onclick="slbmGoPhase(6)">6 ¬∑ STREAM</div>
      </div>
    </div>

    <h3>Gauss‚ÄìLobatto‚ÄìChebyshev Support Nodes</h3>
    <p>On each reference cell [‚àí1,+1]¬≤, the <strong>5 Gauss‚ÄìLobatto points</strong> in 1D are:</p>
    <div class="highlight-box" style="text-align:center;">
      $$\xi_k = -\cos\!\left(\frac{k\pi}{4}\right), \quad k=0,1,2,3,4 \qquad \Longrightarrow \qquad \xi \in \left\{-1,\,-\tfrac{\sqrt{2}}{2},\,0,\,+\tfrac{\sqrt{2}}{2},\,+1\right\}$$
    </div>
    <p>These always include the <strong>endpoints ¬±1</strong> (the cell boundaries), with the interior points clustered towards the edges following a Chebyshev distribution. This <strong>boundary-emphasised clustering</strong> minimises the Lebesgue constant and avoids the Runge phenomenon that plagues equidistant nodes at high polynomial degree.</p>

    <p>In 2D, a 5√ó5 tensor product gives <strong>25 support nodes</strong> per quad cell. The f<sub>q</sub> values at these 25 nodes define a degree-4 polynomial surface from which f<sub>q</sub>(x<sub>D</sub>) can be evaluated at any point inside the cell.</p>

    <div class="info-box" data-label="Reference: Kr√§mer et al. (2017)">
      <p style="margin:0;font-size:0.92rem;">A. Kr√§mer, K. K√ºllmer, D. Reith, W. Joppich, H. Foysi ‚Äî <em>Semi-Lagrangian off-lattice Boltzmann method for weakly compressible flows</em>, Phys. Rev. E 95, 023305 (2017). The method enables second- and higher-order accurate LBM on arbitrary unstructured meshes, with computational cost comparable to the standard lattice Boltzmann method.</p>
    </div>

    <div class="info-box" data-label="Implementation: NATriuM">
      <p style="margin:0 0 10px 0;font-size:0.92rem;"><strong><a href="https://github.com/lettucecfd/NATriuM" target="_blank" rel="noopener" style="color:var(--accent);text-decoration:none;">NATriuM</a></strong> is an open-source C++ solver implementing exactly the algorithm shown in this section ‚Äî Semi-Lagrangian streaming with high-order Gauss‚ÄìLobatto‚ÄìChebyshev interpolation on unstructured meshes. It also provides a spectral-element discontinuous Galerkin (SEDG) streaming alternative and supports 2D/3D weakly and fully compressible viscous flows.</p>
      <p style="margin:0;font-size:0.92rem;">NATriuM is built on top of <strong><a href="https://www.dealii.org" target="_blank" rel="noopener" style="color:var(--accent);text-decoration:none;">deal.II</a></strong>, a widely-used open-source finite element library (C++) that provides unstructured mesh handling, high-order quadrature, and MPI-parallel infrastructure ‚Äî the foundation on which NATriuM's grid management and interpolation are built.</p>
    </div>

    <div class="section-nav">
      <button class="btn" onclick="goSection(7)">‚Üê Applications</button>
      <button class="btn primary" onclick="goSection(0)">‚Ü∫ Start Over</button>
    </div>
  </section>


</div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// NAVIGATION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let currentSection = 0;
const totalSections = 9;

function pauseAllSims() {
  // Lid-driven cavity
  if (typeof running !== 'undefined' && running) {
    running = false;
    const pb = document.getElementById('playBtn');
    if (pb) pb.textContent = '‚ñ∂ PLAY';
  }
  // K√°rm√°n vortex street
  if (typeof kvRunning !== 'undefined' && kvRunning) {
    kvRunning = false;
    const kb = document.getElementById('kvPlayBtn');
    if (kb) kb.textContent = '‚ñ∂ PLAY';
  }
  // Semi-Lagrangian
  if (typeof slbmRunning !== 'undefined' && slbmRunning) {
    slbmRunning = false;
    const sb = document.getElementById('slbmPlayBtn');
    if (sb) sb.textContent = '‚ñ∂ PLAY';
  }
  // Hermite quadrature animation
  if (typeof hqRunning !== 'undefined' && hqRunning) {
    hqRunning = false;
    const hb = document.getElementById('hqPauseBtn');
    if (hb) hb.textContent = '‚ñ∂ PLAY';
  }
}

function goSection(n) {
  pauseAllSims();

  // Show the correct section (sec1b has string id)
  const allSecs = document.querySelectorAll('.section');
  allSecs.forEach(s => s.classList.remove('active'));
  const targetSec = document.getElementById(n === '1b' ? 'sec1b' : 'sec' + n);
  if (targetSec) targetSec.classList.add('active');

  // Highlight nav button ‚Äî button order: 0,1,1b,2,3,4,5,6,7,8
  const navIds = [0,1,'1b',2,3,4,5,6,7,8];
  document.querySelectorAll('.chapter-nav button').forEach((b,i) => {
    b.classList.toggle('active', navIds[i] === n);
  });

  currentSection = n;
  const pct = n === '1b' ? (2.5/totalSections*100) : ((n+1)/totalSections*100);
  document.getElementById('progressFill').style.width = pct + '%';
  window.scrollTo({top:0, behavior:'smooth'});

  if (n === '1b') { hqRunning = true; const hb = document.getElementById('hqPauseBtn'); if(hb) hb.textContent = '‚ñ† PAUSE'; hqStart(); }
  if (n === 4) { scInitIfNeeded(); flyInitIfNeeded(); }
  if (n === 5) { initSim(); running = true; const pb = document.getElementById('playBtn'); if(pb) pb.textContent = '‚ñ† PAUSE'; }
  if (n === 6) { initKarman(); kvRunning = true; const kb = document.getElementById('kvPlayBtn'); if(kb) kb.textContent = '‚ñ† PAUSE'; }
  if (n === 8) { slbmInitIfNeeded(); slbmRunning = true; slbmStart(); const sb = document.getElementById('slbmPlayBtn'); if(sb) sb.textContent = '‚ñ† PAUSE'; }

  if (window.katexOpts) {
    const secId = n === '1b' ? 'sec1b' : 'sec' + n;
    const sec = document.getElementById(secId);
    if (sec) renderMathInElement(sec, window.katexOpts);
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// D2Q9 GRID DEMO
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Grid display uses canvas coords: x right = +1, y DOWN = +1 (same as LBM solver)
// Mapping: col = 1+ex[q], row = 1+ey[q], gidx = row*3+col
//   grid[0]=‚Üñ e‚Çá  grid[1]=‚Üë e‚ÇÑ  grid[2]=‚Üó e‚Çà
//   grid[3]=‚Üê e‚ÇÉ  grid[4]=¬∑ e‚ÇÄ  grid[5]=‚Üí e‚ÇÅ
//   grid[6]=‚Üô e‚ÇÜ  grid[7]=‚Üì e‚ÇÇ  grid[8]=‚Üò e‚ÇÖ
const arrows    = ['‚Üñ','‚Üë','‚Üó','‚Üê','¬∑','‚Üí','‚Üô','‚Üì','‚Üò'];
const velLabels = ['e‚Çá','e‚ÇÑ','e‚Çà','e‚ÇÉ','e‚ÇÄ','e‚ÇÅ','e‚ÇÜ','e‚ÇÇ','e‚ÇÖ'];
const velVectors = [[-1,-1],[0,-1],[1,-1],[-1,0],[0,0],[1,0],[-1,1],[0,1],[1,1]];
const weights   = ['1/36','1/9','1/36','1/9','4/9','1/9','1/36','1/9','1/36'];

function buildGrid() {
  const grid = document.getElementById('d2q9Grid');
  if (!grid) return;
  grid.innerHTML = '';
  for (let i = 0; i < 9; i++) {
    const cell = document.createElement('div');
    cell.className = 'd2q9-cell' + (i === 4 ? ' center' : '');
    cell.innerHTML = `<span class="arrow">${arrows[i]}</span><span class="vel-label">${velLabels[i]}</span>`;
    cell.addEventListener('click', () => {
      const info = document.getElementById('cellInfo');
      const v = velVectors[i];
      info.innerHTML = `<p style="margin:0;font-family:'Space Mono',monospace;font-size:13px">
        <span style="color:var(--accent)">${velLabels[i]}</span> = (${v[0]}, ${v[1]})<br>
        <span style="color:var(--accent2)">weight w = ${weights[i]}</span><br>
        <span style="color:var(--text-dim)">${i===4?'Rest direction ‚Äî particle stays put':i<4?'Diagonal link':'i<5?\'Orthogonal link\':\'Diagonal link\''}</span>
      </p>`;
    });
    grid.appendChild(cell);
  }
}
buildGrid();


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// INTERACTIVE STREAM & COLLIDE CHAPTER
// 7√ó7 D2Q9 lattice, stepped manually through 5 phases per timestep.
//
// Phases:
//   0 ‚Äì Initial state
//   1 ‚Äì Streaming: show arrows indicating which neighbour each cell
//       will pull from (one arrow per direction per cell)
//   2 ‚Äì Post-stream: distributions have moved
//   3 ‚Äì Collision: show Œî = feq - f for every sub-cell
//   4 ‚Äì Post-collision: BGK applied, new equilibrium
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// D2Q9 (same convention as main sim, separate consts to avoid name clash)
const SC_EX  = [ 0,  1,  0, -1,  0,  1, -1, -1,  1];
const SC_EY  = [ 0,  0,  1,  0, -1,  1,  1, -1, -1];
const SC_W   = [4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36];
const SC_OPP = [ 0,  3,  4,  1,  2,  7,  8,  5,  6];

// 3√ó3 sub-grid layout: position index ‚Üí direction index
// Row 0 = top (NW,N,NE), Row 1 = middle (W,rest,E), Row 2 = bottom (SW,S,SE)
// We want y to go UP inside the cell to match physics, so row 0 = north.
const SC_LAYOUT = [6, 2, 5,   3, 0, 1,   7, 4, 8];
// Inverse: direction q ‚Üí sub-grid position index (0‚Äì8)
const SC_POS = new Array(9);
SC_LAYOUT.forEach((q, pos) => { SC_POS[q] = pos; });

const SC_DIR_SYMBOLS = ['¬∑', '‚Üí', '‚Üë', '‚Üê', '‚Üì', '‚Üó', '‚Üñ', '‚Üô', '‚Üò'];
const SC_DIR_NAMES   = ['rest', 'E', 'N', 'W', 'S', 'NE', 'NW', 'SW', 'SE'];

const SCN = 7;  // 7√ó7 lattice
const SC_Q = 9;

// Arrow colours per direction (0=rest has none)
const SC_ARROW_COL = ['', '#00d4ff','#39ff14','#ff6b35','#ffdd00','#aa88ff','#ff4488','#00ffcc','#ff8800'];

// State buffers: scF = current, scFpre = snapshot before stream, scFmid = post-stream
let scF    = new Float64Array(SCN * SCN * SC_Q);
let scFpre = new Float64Array(SCN * SCN * SC_Q);
let scFmid = new Float64Array(SCN * SCN * SC_Q);
let scFeq  = new Float64Array(SCN * SCN * SC_Q);  // equilibrium at mid state
let scHist  = [];   // history of scF snapshots, one per phase, for going back

let scPhase = 0;
let scSelX = 3, scSelY = 3;   // selected cell (default = centre)
let scTau = 0.9;
let scInitDone = false;

const scFidx = (x, y, q) => (y * SCN + x) * SC_Q + q;

function scFeqVal(rho, vx, vy, q) {
  const eu = SC_EX[q]*vx + SC_EY[q]*vy;
  return SC_W[q] * rho * (1 + 3*eu + 4.5*eu*eu - 1.5*(vx*vx+vy*vy));
}

function scMacro(x, y, arr) {
  let r=0, mx=0, my=0;
  for (let q=0; q<SC_Q; q++) {
    const fi = arr[scFidx(x,y,q)];
    r+=fi; mx+=SC_EX[q]*fi; my+=SC_EY[q]*fi;
  }
  return { rho:r, ux:r>1e-12?mx/r:0, uy:r>1e-12?my/r:0 };
}

// ‚îÄ‚îÄ Initialise the lattice ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function scInit() {
  // All cells at equilibrium rho=1, u=0
  for (let y=0; y<SCN; y++)
    for (let x=0; x<SCN; x++)
      for (let q=0; q<SC_Q; q++)
        scF[scFidx(x,y,q)] = scFeqVal(1.0, 0, 0, q);

  // Seed centre cell with higher density + rightward momentum
  for (let q=0; q<SC_Q; q++) scF[scFidx(3,3,q)] = scFeqVal(1.8, 0.15, 0.0, q);
  // Seed cell (1,5) with upward momentum
  for (let q=0; q<SC_Q; q++) scF[scFidx(1,5,q)] = scFeqVal(1.3, 0.0, 0.12, q);
  // Seed cell (5,1) with left+down momentum
  for (let q=0; q<SC_Q; q++) scF[scFidx(5,1,q)] = scFeqVal(1.2, -0.1, -0.08, q);

  scFpre.set(scF);
  scFmid.fill(0); scFeq.fill(0);
  scPhase = 0;
  scHist  = [scF.slice()]; // history[0] = initial
  scSelX = 3; scSelY = 3;
  scInitDone = true;
  scUpdateControls();
  scUpdateExplain();
  scRender();
  scUpdateSidePanel();
}

// ‚îÄ‚îÄ Stream step (pull, periodic) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function scDoStream() {
  const fNew = new Float64Array(SCN * SCN * SC_Q);
  for (let y=0; y<SCN; y++)
    for (let x=0; x<SCN; x++)
      for (let q=0; q<SC_Q; q++) {
        const sx = ((x - SC_EX[q]) + SCN) % SCN;
        const sy = ((y - SC_EY[q]) + SCN) % SCN;
        fNew[scFidx(x,y,q)] = scFpre[scFidx(sx,sy,q)];
      }
  scFmid.set(fNew);
}

// ‚îÄ‚îÄ Collision step (BGK) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function scDoCollision() {
  const omega = 1.0 / scTau;
  for (let y=0; y<SCN; y++)
    for (let x=0; x<SCN; x++) {
      const m = scMacro(x, y, scFmid);
      for (let q=0; q<SC_Q; q++) {
        const eq = scFeqVal(m.rho, m.ux, m.uy, q);
        scFeq[scFidx(x,y,q)] = eq;
        scF[scFidx(x,y,q)] = scFmid[scFidx(x,y,q)] + omega*(eq - scFmid[scFidx(x,y,q)]);
      }
    }
}

// ‚îÄ‚îÄ Phase navigation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function scNext() {
  if (scPhase === 0) {
    scFpre.set(scF);
    scDoStream();                     // compute scFmid
    scPhase = 1;
    scHist[1] = scFpre.slice();
  } else if (scPhase === 1) {
    scPhase = 2;
    scHist[2] = scFmid.slice();
  } else if (scPhase === 2) {
    scDoCollision();                  // compute scFeq + scF (post-collision)
    scPhase = 3;
    scHist[3] = scFmid.slice();
  } else if (scPhase === 3) {
    scPhase = 4;
    scHist[4] = scF.slice();
  } else if (scPhase === 4) {
    // Advance one full timestep and restart
    scFpre.set(scF);
    scDoStream();
    scPhase = 1;
    scHist = [scF.slice(), scFpre.slice()];
  }
  scUpdateControls();
  scUpdateExplain();
  scRender();
  scUpdateSidePanel();
}

function scPrev() {
  if (scPhase <= 0) return;
  scPhase--;
  // Restore the correct buffer for the new phase
  if (scPhase === 0)      scF.set(scHist[0]);
  else if (scPhase === 1) { scFpre.set(scHist[1]); scF.set(scHist[0]); }
  else if (scPhase === 2) scFmid.set(scHist[2]);
  else if (scPhase === 3) { scFmid.set(scHist[3]); }
  scUpdateControls();
  scUpdateExplain();
  scRender();
  scUpdateSidePanel();
}

function scGoPhase(n) {
  if (!scInitDone) return;
  if (n > scPhase) { while(scPhase < n) scNext(); }
  else { while(scPhase > n) scPrev(); }
}

function scReset() { scInit(); }

function scChangeTau(v) {
  scTau = parseFloat(v);
  document.getElementById('scTauVal').textContent = 'œÑ = ' + scTau.toFixed(1);
  document.getElementById('scNuVal').textContent  = ((1/3)*(scTau-0.5)).toFixed(3);
  document.getElementById('scOmegaVal').textContent = (1/scTau).toFixed(3);
  // Recompute equilibrium if we're past phase 2
  if (scPhase >= 3) { scDoCollision(); scRender(); scUpdateSidePanel(); }
}

function scUpdateControls() {
  document.getElementById('scPrevBtn').disabled = (scPhase === 0);
  document.getElementById('scNextBtn').textContent = scPhase === 4 ? 'NEXT TIMESTEP ‚Üí' : 'NEXT STEP ‚Üí';
  // Track bar
  for (let i=0; i<5; i++) {
    const el = document.getElementById('scTrack'+i);
    if (el) el.classList.toggle('active-track', i === scPhase);
  }
  // Arrow pulse animation: only run during streaming phase
  if (scPhase === 1) scStartArrowAnim();
  else scStopArrowAnim();
}

// ‚îÄ‚îÄ Explanation texts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const SC_EXPLAINS = [
  `This is the <strong>initial state</strong> ‚Äî before any evolution. Three cells have been seeded with non-equilibrium distributions: the <strong>centre (3,3)</strong> has high density (œÅ=1.8) with rightward momentum, <strong>(1,5)</strong> has upward momentum, and <strong>(5,1)</strong> has leftward+downward momentum. All other cells sit at rest equilibrium (œÅ=1, u=0). <em>Click any cell</em> to inspect its 9 f·µ¢ values in the panel to the right.`,

  `<strong>Streaming step ‚Äî arrows phase.</strong> Each coloured arrow shows a distribution f·µ¢ that is about to travel to a neighbouring cell. In <em>pull streaming</em>, every node will pull value f·µ¢ from the node one step upstream (in direction ‚àíe·µ¢). Arrows are scaled by the magnitude of f·µ¢ ‚Äî brighter/thicker means more "mass" is moving. The rest population (i=0, centre dot) stays in place. <em>Click a cell to see which values it will receive and from where.</em>`,

  `<strong>Post-stream state.</strong> Each cell has now pulled distributions from its neighbours. The high-density blob from (3,3) has begun spreading outward: the cells north, east, south and west of it now hold elevated f·µ¢ values in the directions that pointed toward (3,3). Total mass (sum of all f·µ¢ across all cells) is <em>exactly conserved</em> ‚Äî streaming only moves populations around, never creates or destroys them. Select any cell to compare its new f·µ¢ values with the pre-stream values.`,

  `<strong>Collision step ‚Äî relaxation.</strong> For each cell we compute the local equilibrium distribution f·µ¢·µâq(œÅ, <b>u</b>) using the macroscopic density and velocity just computed from the streamed f·µ¢. Each f·µ¢ is then nudged toward f·µ¢·µâq by a fraction 1/œÑ = œâ. <span style="color:#39ff14">Green</span> sub-cells will <em>increase</em>; <span style="color:#ff4466">red</span> sub-cells will <em>decrease</em>. The larger the |Œî|, the further the system was from equilibrium in that direction. Select a cell to see the exact Œî values.`,

  `<strong>Post-collision state.</strong> BGK has been applied: every f·µ¢ has moved a fraction 1/œÑ of the way toward equilibrium. The distributions are now smoother and more isotropic. This completes one full LBM timestep (stream ‚Üí collide). Press <em>Next Timestep</em> to advance another step and watch how the density disturbances propagate as acoustic waves across the periodic lattice.`,
];

function scUpdateExplain() {
  document.getElementById('scPhasePill').textContent =
    ['INITIAL STATE','STREAMING ‚Äî ARROWS','POST-STREAM','COLLISION ‚Äî Œî','POST-COLLISION'][scPhase];
  document.getElementById('scExplainText').innerHTML = SC_EXPLAINS[scPhase];
}

// ‚îÄ‚îÄ Which f-array to draw for the current phase ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function scCurrentF() {
  if (scPhase === 0 || scPhase === 1) return scFpre;
  if (scPhase === 2 || scPhase === 3) return scFmid;
  return scF;  // phase 4
}

// ‚îÄ‚îÄ Canvas rendering ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function scRender() {
  const canvas = document.getElementById('scCanvas');
  if (!canvas) return;
  const ctx  = canvas.getContext('2d');
  const CW   = canvas.width, CH = canvas.height;
  const CELL = CW / SCN;          // px per lattice cell
  const PAD  = 5;
  const SUB  = (CELL - PAD*2) / 3;  // px per f sub-cell

  ctx.clearRect(0, 0, CW, CH);
  ctx.fillStyle = '#080c10';
  ctx.fillRect(0, 0, CW, CH);

  const drawF = scCurrentF();

  // Global max-f for colour normalisation (only fluid cells)
  let maxF = 1e-9;
  for (let i=0; i<drawF.length; i++) if (drawF[i] > maxF) maxF = drawF[i];

  // ‚îÄ‚îÄ Draw cells ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  for (let y=0; y<SCN; y++) {
    for (let x=0; x<SCN; x++) {
      const cx = x * CELL;
      const cy = (SCN-1-y) * CELL;   // flip y: y=0 at bottom
      const isSel = (x===scSelX && y===scSelY);

      // Cell background
      ctx.fillStyle = isSel ? 'rgba(0,212,255,0.10)' : '#0d1520';
      ctx.fillRect(cx+1, cy+1, CELL-2, CELL-2);

      // Cell border
      ctx.strokeStyle = isSel ? '#00d4ff' : '#1a3550';
      ctx.lineWidth   = isSel ? 1.5 : 0.5;
      ctx.strokeRect(cx+1, cy+1, CELL-2, CELL-2);

      // Phase 3 out-of-eq glow
      if (scPhase === 3) {
        let totalDelta = 0;
        for (let q=0; q<SC_Q; q++)
          totalDelta += Math.abs(scFeq[scFidx(x,y,q)] - scFmid[scFidx(x,y,q)]);
        if (totalDelta > 0.005) {
          const alpha = Math.min(totalDelta * 1.2, 0.45);
          ctx.fillStyle = `rgba(255,107,53,${alpha.toFixed(2)})`;
          ctx.fillRect(cx+2, cy+2, CELL-4, CELL-4);
        }
      }

      // ‚îÄ‚îÄ Sub-cells (3√ó3 f values) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      for (let si=0; si<9; si++) {
        const q    = SC_LAYOUT[si];
        const sCol = si % 3;
        const sRow = Math.floor(si / 3);
        const subX = cx + PAD + sCol*SUB;
        const subY = cy + PAD + sRow*SUB;

        const fval = drawF[scFidx(x,y,q)];
        const t    = Math.min(fval / maxF, 1);

        // Colour: dark navy ‚Üí bright cyan based on value
        const r = Math.round(t * 100);
        const g = Math.round(t * 200);
        const b = Math.round(60 + t * 195);
        ctx.fillStyle = `rgb(${r},${g},${b})`;
        ctx.fillRect(subX+0.5, subY+0.5, SUB-1, SUB-1);

        // Phase 3: overlay green/red delta
        if (scPhase === 3) {
          const delta = scFeq[scFidx(x,y,q)] - fval;
          if (Math.abs(delta) > 0.001) {
            const alpha2 = Math.min(Math.abs(delta)*10, 0.75);
            ctx.fillStyle = delta>0 ? `rgba(57,255,20,${alpha2.toFixed(2)})` : `rgba(255,68,102,${alpha2.toFixed(2)})`;
            ctx.fillRect(subX+0.5, subY+0.5, SUB-1, SUB-1);
          }
        }

        // f value text
        const textBright = t > 0.55;
        ctx.fillStyle  = textBright ? 'rgba(0,0,0,0.85)' : 'rgba(100,160,200,0.9)';
        ctx.font       = `${Math.max(7, Math.round(SUB*0.27))}px 'Space Mono',monospace`;
        ctx.textAlign  = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(fval.toFixed(3), subX + SUB/2, subY + SUB/2);
      }

      // Coordinate label
      ctx.fillStyle    = '#1e3a5a';
      ctx.font         = `8px 'Space Mono',monospace`;
      ctx.textAlign    = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText(`${x},${y}`, cx+3, cy+3);
    }
  }

  // ‚îÄ‚îÄ Phase 1: Streaming arrows ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if (scPhase === 1) {
    scDrawStreamArrows(ctx, CELL, PAD, SUB);
  }

  // ‚îÄ‚îÄ Selected cell highlight ring ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const hx = scSelX * CELL, hy = (SCN-1-scSelY)*CELL;
  ctx.strokeStyle = 'rgba(0,212,255,0.9)';
  ctx.lineWidth   = 2;
  ctx.setLineDash([]);
  ctx.strokeRect(hx+1, hy+1, CELL-2, CELL-2);
}

// ‚îÄ‚îÄ Streaming arrows: bold cell-to-cell arrows, blue‚Üíred by magnitude ‚îÄ‚îÄ
// Each arrow travels from the centre of its source cell to the centre of
// its destination cell. Colour maps f·µ¢ magnitude: blue (low) ‚Üí red (high).
// Thickness and opacity also scale with magnitude for perceptual clarity.

let scArrowAnimT = 0;      // 0..1, driven by rAF when phase===1
let scArrowAnimRAF = null;

function scMagToColor(t) {
  // Jet-style blue‚Üícyan‚Üígreen‚Üíyellow‚Üíred, t in [0,1]
  let r, g, b;
  if      (t < 0.25) { r=0;              g=t*4;           b=1;             }
  else if (t < 0.5)  { r=0;              g=1;             b=1-(t-0.25)*4;  }
  else if (t < 0.75) { r=(t-0.5)*4;     g=1;             b=0;             }
  else               { r=1;              g=1-(t-0.75)*4;  b=0;             }
  return [Math.round(r*255), Math.round(g*255), Math.round(b*255)];
}

function scDrawStreamArrows(ctx, CELL, PAD, SUB) {
  // Find global max f·µ¢ across all cells/directions for normalisation
  let maxF = 1e-9;
  for (let y=0; y<SCN; y++)
    for (let x=0; x<SCN; x++)
      for (let q=1; q<SC_Q; q++) {
        const v = scFpre[scFidx(x,y,q)];
        if (v > maxF) maxF = v;
      }

  // Collect all arrows into an array so we can depth-sort (draw faint ones first)
  const arrows = [];
  for (let y=0; y<SCN; y++) {
    for (let x=0; x<SCN; x++) {
      for (let q=1; q<SC_Q; q++) {
        const fval = scFpre[scFidx(x,y,q)];
        if (fval < 0.002) continue;

        // Source: centre of source cell (offset slightly toward the sub-cell
        // position so the arrow visually originates from the right quadrant)
        const pos  = SC_POS[q];                    // 0-8 position in the 3√ó3 sub-grid
        const sCol = pos % 3, sRow = Math.floor(pos / 3);
        // Sub-cell centre within source cell
        const subCX = x*CELL + PAD + sCol*SUB + SUB/2;
        const subCY = (SCN-1-y)*CELL + PAD + sRow*SUB + SUB/2;
        // Cell centre
        const cellCX = x*CELL + CELL/2;
        const cellCY = (SCN-1-y)*CELL + CELL/2;
        // Source point: blend between sub-cell and cell centre (leans toward the quadrant)
        const srcX = cellCX + (subCX - cellCX) * 0.55;
        const srcY = cellCY + (subCY - cellCY) * 0.55;

        // Destination cell
        const dx = ((x + SC_EX[q]) + SCN) % SCN;
        const dy = ((y + SC_EY[q]) + SCN) % SCN;

        // Skip periodic wraps that jump across the whole canvas (confusing visually)
        if (Math.abs(dx-x) > 1 || Math.abs(dy-y) > 1) continue;

        const dstCX = dx*CELL + CELL/2;
        const dstCY = (SCN-1-dy)*CELL + CELL/2;

        const t = Math.min(fval / maxF, 1);
        arrows.push({ srcX, srcY, dstCX, dstCY, fval, t, q });
      }
    }
  }

  // Sort: low magnitude first (drawn underneath), high magnitude on top
  arrows.sort((a,b) => a.t - b.t);

  ctx.save();
  ctx.setLineDash([]);

  for (const { srcX, srcY, dstCX, dstCY, fval, t } of arrows) {
    const [r, g, b] = scMagToColor(t);

    // Arrow shaft thickness: 1px (faint) ‚Üí 5px (strong)
    const lw     = 1.0 + t * 4.5;
    // Animated pulse: the alpha gently oscillates so you can see the flow
    const pulse  = 0.7 + 0.3 * Math.sin(scArrowAnimT * Math.PI * 2);
    const alpha  = (0.35 + t * 0.6) * pulse;

    const angle  = Math.atan2(dstCY - srcY, dstCX - srcX);
    const dist   = Math.hypot(dstCY - srcY, dstCX - srcX);

    // Stop the shaft just before the destination centre so the head fits cleanly
    const headLen = 10 + t * 8;
    const stopFrac = Math.max(0, (dist - headLen - 4) / dist);
    const shaftEndX = srcX + (dstCX - srcX) * stopFrac;
    const shaftEndY = srcY + (dstCY - srcY) * stopFrac;

    // ‚îÄ‚îÄ Glow pass (wide, very transparent) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    ctx.globalAlpha = alpha * 0.35;
    ctx.strokeStyle = `rgb(${r},${g},${b})`;
    ctx.lineWidth   = lw + 6;
    ctx.lineCap     = 'round';
    ctx.beginPath();
    ctx.moveTo(srcX, srcY);
    ctx.lineTo(shaftEndX, shaftEndY);
    ctx.stroke();

    // ‚îÄ‚îÄ Main shaft ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    ctx.globalAlpha = alpha;
    ctx.lineWidth   = lw;
    ctx.beginPath();
    ctx.moveTo(srcX, srcY);
    ctx.lineTo(shaftEndX, shaftEndY);
    ctx.stroke();

    // ‚îÄ‚îÄ Arrowhead (filled triangle) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    ctx.globalAlpha = alpha;
    ctx.fillStyle   = `rgb(${r},${g},${b})`;
    const hw = 4 + t * 5;   // half-width of arrowhead base
    ctx.beginPath();
    ctx.moveTo(dstCX, dstCY);
    ctx.lineTo(dstCX - headLen*Math.cos(angle-0.42), dstCY - headLen*Math.sin(angle-0.42));
    ctx.lineTo(dstCX - headLen*Math.cos(angle+0.42), dstCY - headLen*Math.sin(angle+0.42));
    ctx.closePath();
    ctx.fill();
  }

  ctx.globalAlpha = 1;
  ctx.lineCap = 'butt';
  ctx.restore();
}

// Start/stop the pulsing animation when phase changes
function scStartArrowAnim() {
  if (scArrowAnimRAF) return;
  let last = null;
  function tick(ts) {
    if (scPhase !== 1) { scArrowAnimRAF = null; return; }
    if (last !== null) scArrowAnimT = (scArrowAnimT + (ts - last) / 1800) % 1;
    last = ts;
    scRender();
    scArrowAnimRAF = requestAnimationFrame(tick);
  }
  scArrowAnimRAF = requestAnimationFrame(tick);
}

function scStopArrowAnim() {
  if (scArrowAnimRAF) { cancelAnimationFrame(scArrowAnimRAF); scArrowAnimRAF = null; }
}

// ‚îÄ‚îÄ Side panel update ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function scUpdateSidePanel() {
  const x = scSelX, y = scSelY;
  const drawF = scCurrentF();
  const m = scMacro(x, y, drawF);

  document.getElementById('scSelLabel').textContent = `(${x}, ${y})`;
  document.getElementById('scRhoVal').textContent   = m.rho.toFixed(4);
  document.getElementById('scUxVal').textContent    = m.ux.toFixed(4);
  document.getElementById('scUyVal').textContent    = m.uy.toFixed(4);

  // Rebuild 3√ó3 f-value grid
  const fgrid = document.getElementById('scFGrid');
  fgrid.innerHTML = '';
  for (let si=0; si<9; si++) {
    const q    = SC_LAYOUT[si];
    const fval = drawF[scFidx(x,y,q)];

    let deltaHtml = '';
    if (scPhase === 3) {
      const delta = scFeq[scFidx(x,y,q)] - fval;
      if (Math.abs(delta) > 0.0005) {
        const col = delta > 0 ? '#39ff14' : '#ff4466';
        deltaHtml = `<div style="color:${col};font-size:9px;line-height:1.3;">${delta>0?'+':''}${delta.toFixed(4)}</div>`;
      }
    }

    const isHighlighted = (scPhase === 1);
    const arrowSym = q===0 ? '¬∑' : SC_DIR_SYMBOLS[q];
    fgrid.innerHTML += `
      <div style="background:var(--surface2);border:1px solid ${isHighlighted?SC_ARROW_COL[q]||'var(--border)':'var(--border)'};
                  padding:6px 4px;border-radius:2px;text-align:center;">
        <div style="font-size:14px;color:${SC_ARROW_COL[q]||'var(--text-dim)'};">${arrowSym}</div>
        <div style="font-family:'Space Mono',monospace;font-size:10px;color:var(--text-dim);">${SC_DIR_NAMES[q]}</div>
        <div style="font-family:'Space Mono',monospace;font-size:11px;color:var(--accent);margin-top:2px;">${fval.toFixed(4)}</div>
        ${deltaHtml}
      </div>`;
  }

  // Source note (streaming phase)
  const srcNote = document.getElementById('scSourceNote');
  const collNote = document.getElementById('scCollNote');

  if (scPhase === 1) {
    srcNote.style.display = 'block';
    collNote.style.display = 'none';
    let lines = [`Cell <b style="color:var(--accent)">(${x},${y})</b> will pull from:`];
    for (let q=1; q<SC_Q; q++) {
      const sx = ((x - SC_EX[q]) + SCN) % SCN;
      const sy = ((y - SC_EY[q]) + SCN) % SCN;
      const fval = scFpre[scFidx(sx,sy,q)];
      if (fval > 0.001) {
        lines.push(`<span style="color:${SC_ARROW_COL[q]}">${SC_DIR_NAMES[q]} (${SC_DIR_SYMBOLS[q]})</span> ‚Üê f${q} from (${sx},${sy}) = <b>${fval.toFixed(4)}</b>`);
      }
    }
    srcNote.innerHTML = lines.join('<br>');
  } else if (scPhase === 3) {
    srcNote.style.display = 'none';
    collNote.style.display = 'block';
    const eq = scMacro(x, y, scFmid);
    let totalAbsDelta = 0;
    for (let q=0; q<SC_Q; q++) totalAbsDelta += Math.abs(scFeq[scFidx(x,y,q)] - scFmid[scFidx(x,y,q)]);
    collNote.innerHTML =
      `œÅ=<b style="color:var(--accent)">${eq.rho.toFixed(3)}</b>, u‚Çì=<b style="color:var(--accent2)">${eq.ux.toFixed(3)}</b>, u·µß=<b style="color:var(--accent2)">${eq.uy.toFixed(3)}</b><br>` +
      `œâ = 1/œÑ = <b style="color:var(--accent)">${(1/scTau).toFixed(3)}</b><br>` +
      `Total |Œî| = <b style="color:${totalAbsDelta > 0.05 ? '#ff6b35':'#39ff14'}">${totalAbsDelta.toFixed(4)}</b><br>` +
      `<span style="color:var(--text-dim);font-size:10px;">f_new = f + œâ¬∑(feq ‚àí f)</span>`;
  } else {
    srcNote.style.display = 'none';
    collNote.style.display = 'none';
  }
}

// ‚îÄ‚îÄ Canvas click ‚Üí select cell ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function scSetupCanvasClick() {
  const canvas = document.getElementById('scCanvas');
  if (!canvas || canvas._scClickBound) return;
  canvas._scClickBound = true;
  canvas.addEventListener('click', e => {
    const rect   = canvas.getBoundingClientRect();
    const scaleX = canvas.width  / rect.width;
    const scaleY = canvas.height / rect.height;
    const px = (e.clientX - rect.left) * scaleX;
    const py = (e.clientY - rect.top)  * scaleY;
    const CELL = canvas.width / SCN;
    const gx   = Math.floor(px / CELL);
    const gy   = SCN-1 - Math.floor(py / CELL);
    if (gx>=0 && gx<SCN && gy>=0 && gy<SCN) {
      scSelX = gx; scSelY = gy;
      scRender();
      scUpdateSidePanel();
    }
  });
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// FLYING-BULLET STREAMING ANIMATION
//
// A 3√ó3 grid of nodes (with margin nodes on each side = 5√ó5 visible,
// but only the inner 3√ó3 are "active"). Each timestep, every node
// fires a "bullet" in each of the 8 non-rest directions. The bullet
// travels at constant pixel speed from the source node centre to the
// destination node centre. Colour = jet(f·µ¢ / maxF), size ‚àù f·µ¢.
//
// The LBM state is a tiny 5√ó5 periodic lattice that gets streamed +
// collided each wave so the distributions evolve naturally.
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const FLY_N   = 5;       // 5√ó5 lattice (inner 3√ó3 are the "hero" nodes)
const FLY_Q   = 9;
const FLY_EX  = [ 0,  1,  0, -1,  0,  1, -1, -1,  1];
const FLY_EY  = [ 0,  0,  1,  0, -1,  1,  1, -1, -1];
const FLY_W   = [4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36];
const FLY_OPP = [ 0,  3,  4,  1,  2,  7,  8,  5,  6];

// Direction name + symbol for the info panel
const FLY_DIR_SYM = ['¬∑','‚Üí','‚Üë','‚Üê','‚Üì','‚Üó','‚Üñ','‚Üô','‚Üò'];

let flyF    = new Float64Array(FLY_N * FLY_N * FLY_Q);
let flyFtmp = new Float64Array(FLY_N * FLY_N * FLY_Q);

const flyFidx = (x, y, q) => (y * FLY_N + x) * FLY_Q + q;

function flyFeq(rho, vx, vy, q) {
  const eu = FLY_EX[q]*vx + FLY_EY[q]*vy;
  return FLY_W[q] * rho * (1 + 3*eu + 4.5*eu*eu - 1.5*(vx*vx+vy*vy));
}

function flyMacro(x, y) {
  let r=0, mx=0, my=0;
  for (let q=0; q<FLY_Q; q++) {
    const fi = flyF[flyFidx(x,y,q)];
    r+=fi; mx+=FLY_EX[q]*fi; my+=FLY_EY[q]*fi;
  }
  return { rho:r, ux:r>1e-12?mx/r:0, uy:r>1e-12?my/r:0 };
}

function flyInitState() {
  // Uniform equilibrium everywhere
  for (let y=0; y<FLY_N; y++)
    for (let x=0; x<FLY_N; x++)
      for (let q=0; q<FLY_Q; q++)
        flyF[flyFidx(x,y,q)] = flyFeq(1.0, 0, 0, q);
  // Seed interesting non-equilibrium blobs in the inner nodes
  for (let q=0; q<FLY_Q; q++) flyF[flyFidx(2,2,q)] = flyFeq(1.9, 0.14, 0.0,  q);
  for (let q=0; q<FLY_Q; q++) flyF[flyFidx(1,3,q)] = flyFeq(1.4, 0.0,  0.12, q);
  for (let q=0; q<FLY_Q; q++) flyF[flyFidx(3,1,q)] = flyFeq(1.3,-0.1, -0.08, q);
}

const STREAM_DUR = 1.5;   // seconds for streaming animation
const HOLD_DUR   = 0.9;   // seconds to hold stencil before next timestep

let flyPhase      = 'stream';
let flyPhaseTimer = 0;
let flySpeed      = 1.0;
let flyRunning    = true;
let flyRAF        = null;
let flyLastTs     = null;
let flyFocusNode  = null;
let flyInitDone   = false;
let flyMaxF       = 1.0;
let flyFpre       = null;   // f snapshot before streaming
let flyFpost      = null;   // f snapshot after streaming
let flyFcoll      = null;   // f snapshot after collision

// ‚îÄ‚îÄ Colour helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function flyMagToColor(t) {
  t = Math.max(0, Math.min(1, t));
  let r, g, b;
  if      (t < 0.25) { r=0;          g=t*4;          b=1;            }
  else if (t < 0.5)  { r=0;          g=1;            b=1-(t-0.25)*4; }
  else if (t < 0.75) { r=(t-0.5)*4; g=1;            b=0;            }
  else               { r=1;          g=1-(t-0.75)*4; b=0;            }
  return [r*255|0, g*255|0, b*255|0];
}
function flyColor(t) {
  const [r,g,b] = flyMagToColor(t); return `rgb(${r},${g},${b})`;
}
function flyColorA(t, a) {
  const [r,g,b] = flyMagToColor(t); return `rgba(${r},${g},${b},${a.toFixed(3)})`;
}

// ‚îÄ‚îÄ Arrow drawing ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function flyDrawArrow(ctx, tipX, tipY, angle, length, width, col, alpha) {
  if (length < 3) return;
  const headLen = Math.min(Math.max(7, width * 3.5), length * 0.40);
  const headWid = Math.max(width * 1.8, headLen * 0.55);
  const cos = Math.cos(angle), sin = Math.sin(angle);
  const tailX = tipX - cos * length, tailY = tipY - sin * length;
  const shaftEndX = tipX - cos * headLen, shaftEndY = tipY - sin * headLen;

  ctx.globalAlpha = alpha * 0.25;
  ctx.strokeStyle = col; ctx.lineWidth = width * 3.2; ctx.lineCap = 'round';
  ctx.beginPath(); ctx.moveTo(tailX, tailY); ctx.lineTo(shaftEndX, shaftEndY); ctx.stroke();

  ctx.globalAlpha = alpha;
  ctx.lineWidth = width; ctx.lineCap = 'round'; ctx.strokeStyle = col;
  ctx.beginPath(); ctx.moveTo(tailX, tailY); ctx.lineTo(shaftEndX, shaftEndY); ctx.stroke();

  ctx.fillStyle = col;
  ctx.beginPath();
  ctx.moveTo(tipX, tipY);
  ctx.lineTo(shaftEndX - sin * headWid, shaftEndY + cos * headWid);
  ctx.lineTo(shaftEndX + sin * headWid, shaftEndY - cos * headWid);
  ctx.closePath(); ctx.fill();

  ctx.globalAlpha = 1; ctx.lineCap = 'butt';
}

// ‚îÄ‚îÄ Run stream only (no collision) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function flyDoStream() {
  for (let y=0; y<FLY_N; y++)
    for (let x=0; x<FLY_N; x++)
      for (let q=0; q<FLY_Q; q++) {
        const sx = ((x - FLY_EX[q]) + FLY_N) % FLY_N;
        const sy = ((y - FLY_EY[q]) + FLY_N) % FLY_N;
        flyFtmp[flyFidx(x,y,q)] = flyF[flyFidx(sx,sy,q)];
      }
  flyF.set(flyFtmp);
}

// ‚îÄ‚îÄ Run BGK collision in-place ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function flyDoCollide() {
  const omega = 1 / 0.9;
  for (let y=0; y<FLY_N; y++)
    for (let x=0; x<FLY_N; x++) {
      let r=0, mx=0, my=0;
      for (let q=0; q<FLY_Q; q++) {
        const fi = flyF[flyFidx(x,y,q)];
        r+=fi; mx+=FLY_EX[q]*fi; my+=FLY_EY[q]*fi;
      }
      const ux = r>1e-12?mx/r:0, uy = r>1e-12?my/r:0;
      for (let q=0; q<FLY_Q; q++) {
        const fi = flyF[flyFidx(x,y,q)];
        flyF[flyFidx(x,y,q)] = fi + omega * (flyFeq(r,ux,uy,q) - fi);
      }
    }
}

// ‚îÄ‚îÄ Prepare a new timestep ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function flyPrepareWave() {
  flyFpre = flyF.slice();     // stencil at streamP=0

  flyDoStream();
  flyFpost = flyF.slice();    // stencil at streamP=1

  flyDoCollide();
  flyFcoll = flyF.slice();    // stencil shown during hold (post-collision)

  flyMaxF = 1e-9;
  for (let i=0; i<flyFpre.length; i++) {
    if (flyFpre[i]  > flyMaxF) flyMaxF = flyFpre[i];
    if (flyFpost[i] > flyMaxF) flyMaxF = flyFpost[i];
    if (flyFcoll[i] > flyMaxF) flyMaxF = flyFcoll[i];
  }
  flyPhase      = 'stream';
  flyPhaseTimer = 0;
  flyUpdateInfoPanel();
}

function flyUpdateInfoPanel() {
  if (!flyFocusNode) {
    document.getElementById('flyNodeLabel').textContent = 'all';
    document.getElementById('flyRho').textContent       = '‚Äî';
    document.getElementById('flyUx').textContent        = '‚Äî';
    document.getElementById('flyUy').textContent        = '‚Äî';
    document.getElementById('flyInFlight').innerHTML    = '';
    return;
  }
  const { x, y } = flyFocusNode;
  const m = flyMacro(x, y);
  document.getElementById('flyNodeLabel').textContent = `(${x},${y})`;
  document.getElementById('flyRho').textContent       = m.rho.toFixed(3);
  document.getElementById('flyUx').textContent        = m.ux.toFixed(3);
  document.getElementById('flyUy').textContent        = m.uy.toFixed(3);
  if (flyFpre) {
    const lines = [];
    for (let q=1; q<FLY_Q; q++) {
      const fval = flyFpre[flyFidx(x,y,q)];
      if (fval < 0.001) continue;
      lines.push(`<span style="color:${flyColor(fval/flyMaxF)}">${FLY_DIR_SYM[q]}</span> f${q}=<b style="color:var(--text)">${fval.toFixed(3)}</b>`);
    }
    document.getElementById('flyInFlight').innerHTML = lines.join('<br>');
  }
}

// ‚îÄ‚îÄ Core rendering ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Two phases per timestep:
//
// STREAM phase: flying arrows travel tail‚Üítip from source to
//   destination along lattice links (periodic wrapping handled).
//   Stencil shown faintly in background so nodes are readable.
//
// HOLD phase: arrows at rest at destination.  A brief sinusoidal
//   "shake" (small perpendicular wobble) signals the BGK collision
//   redistributing populations, then the cycle repeats.
//
// Arrow geometry: tail starts at source node, tip is BASE_LEN ahead.
//   At streamP=1 tail is at destination ‚Äî arrow becomes the stencil arm.
//   Magnitude ‚Üí shaft width + colour (never arm length).
function flyRender(dt) {
  const canvas = document.getElementById('flyCanvas');
  if (!canvas) return;
  const ctx    = canvas.getContext('2d');
  const CW     = canvas.width, CH = canvas.height;
  const MARGIN = CW * 0.12;
  const STEP   = (CW - 2*MARGIN) / (FLY_N - 1);
  const NODE_R = STEP * 0.075;
  const BASE   = STEP * 0.30;   // orthogonal arm length; diagonal = ‚àö2 √ó BASE

  // ‚îÄ‚îÄ Advance timer ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  flyPhaseTimer += dt * flySpeed;
  if (flyPhase === 'stream' && flyPhaseTimer >= STREAM_DUR) {
    flyPhase = 'hold'; flyPhaseTimer = 0;
  }
  if (flyPhase === 'hold' && flyPhaseTimer >= HOLD_DUR) {
    flyPrepareWave(); return;
  }
  if (!flyFpre || !flyFpost || !flyFcoll) return;

  // stream progress 0‚Üí1, sinusoidal ease-in-out
  const rawP    = flyPhase === 'stream' ? Math.min(flyPhaseTimer / STREAM_DUR, 1) : 1;
  const streamP = 0.5 - 0.5 * Math.cos(rawP * Math.PI);

  // Collision pulse: during hold, arm length shrinks then grows back.
  const holdP     = flyPhase === 'hold' ? Math.min(flyPhaseTimer / HOLD_DUR, 1) : 0;
  const shakeFrac = 0.40 * Math.sin(Math.PI * holdP);

  // ‚îÄ‚îÄ Clear ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  ctx.clearRect(0, 0, CW, CH);
  ctx.fillStyle = '#06090e'; ctx.fillRect(0, 0, CW, CH);

  // ‚îÄ‚îÄ Grid lines ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  ctx.strokeStyle = 'rgba(30,58,95,0.55)'; ctx.lineWidth = 0.5;
  for (let i = 0; i < FLY_N; i++) {
    const px = MARGIN + i*STEP, py = CH - MARGIN - i*STEP;
    ctx.beginPath(); ctx.moveTo(px, MARGIN); ctx.lineTo(px, CH-MARGIN); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(MARGIN, py); ctx.lineTo(CW-MARGIN, py); ctx.stroke();
  }

  // ‚îÄ‚îÄ Lattice link lines ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  ctx.strokeStyle = 'rgba(20,45,75,0.7)'; ctx.lineWidth = 0.8;
  for (let sy = 0; sy < FLY_N; sy++)
    for (let sx = 0; sx < FLY_N; sx++)
      for (let q = 1; q <= 4; q++) {
        const dx = ((sx+FLY_EX[q])+FLY_N)%FLY_N;
        const dy = ((sy+FLY_EY[q])+FLY_N)%FLY_N;
        if (Math.abs(dx-sx)>1 || Math.abs(dy-sy)>1) continue;
        ctx.beginPath();
        ctx.moveTo(MARGIN+sx*STEP, CH-MARGIN-sy*STEP);
        ctx.lineTo(MARGIN+dx*STEP, CH-MARGIN-dy*STEP);
        ctx.stroke();
      }

  // ‚îÄ‚îÄ Flying / settled arrows ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const drawArrows = [];

  for (let sy = 0; sy < FLY_N; sy++) {
    for (let sx = 0; sx < FLY_N; sx++) {
      for (let q = 1; q < FLY_Q; q++) {
        const fval = flyFpre[flyFidx(sx, sy, q)];
        if (fval < 0.0005) continue;

        const t        = Math.min(fval / flyMaxF, 1);
        const isDiag   = FLY_EX[q] !== 0 && FLY_EY[q] !== 0;
        const BASE_ARM = BASE * (isDiag ? Math.SQRT2 : 1);
        const armLen   = BASE_ARM * (1 - shakeFrac);
        const arrowWid = 1.5 + t * 3.5;
        const col      = flyColor(t);

        const x0 = MARGIN + sx * STEP;
        const y0 = CH - MARGIN - sy * STEP;

        const ddx = ((sx+FLY_EX[q])+FLY_N)%FLY_N;
        const ddy = ((sy+FLY_EY[q])+FLY_N)%FLY_N;
        const x1  = MARGIN + ddx * STEP;
        const y1  = CH - MARGIN - ddy * STEP;

        const angle = Math.atan2(-FLY_EY[q], FLY_EX[q]);

        const wrapX = Math.abs(x1-x0) > STEP*1.5;
        const wrapY = Math.abs(y1-y0) > STEP*1.5;
        const wrap  = wrapX || wrapY;

        let tailX, tailY;
        if (flyPhase === 'stream') {
          tailX = x0 + FLY_EX[q] * STEP * streamP;
          tailY = y0 - FLY_EY[q] * STEP * streamP;
        } else {
          tailX = x1;
          tailY = y1;
        }

        const tipX = tailX + Math.cos(angle) * armLen;
        const tipY = tailY + Math.sin(angle) * armLen;

        const isFocus   = flyFocusNode && sx===flyFocusNode.x && sy===flyFocusNode.y;
        const nodeAlpha = isFocus ? 1.0 : (flyFocusNode ? 0.20 : 0.92);

        drawArrows.push({ tipX, tipY, angle, armLen, arrowWid, col, nodeAlpha, t });

        if (wrap && flyPhase === 'stream') {
          const offX = wrapX ? -FLY_EX[q] * STEP * FLY_N : 0;
          const offY = wrapY ?  FLY_EY[q] * STEP * FLY_N : 0;
          drawArrows.push({
            tipX: tipX + offX, tipY: tipY + offY,
            angle, armLen, arrowWid, col,
            nodeAlpha: nodeAlpha * 0.65, t
          });
        }
      }
    }
  }

  drawArrows.sort((a,b) => a.t - b.t);
  for (const a of drawArrows) {
    flyDrawArrow(ctx, a.tipX, a.tipY, a.angle, a.armLen, a.arrowWid, a.col, a.nodeAlpha);
  }

  // ‚îÄ‚îÄ Rest population dots ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  for (let sy = 0; sy < FLY_N; sy++) {
    for (let sx = 0; sx < FLY_N; sx++) {
      const fval = flyFpre[flyFidx(sx, sy, 0)];
      if (fval < 0.0001) continue;
      const t   = Math.min(fval / flyMaxF, 1);
      const nx  = MARGIN + sx*STEP, ny = CH - MARGIN - sy*STEP;
      const isFocus   = flyFocusNode && sx===flyFocusNode.x && sy===flyFocusNode.y;
      const nodeAlpha = isFocus ? 1.0 : (flyFocusNode ? 0.20 : 0.92);
      ctx.globalAlpha = nodeAlpha * 0.9;
      ctx.fillStyle   = flyColor(t);
      ctx.beginPath(); ctx.arc(nx, ny, (3 + t*5) * (1 - shakeFrac*0.5), 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  // ‚îÄ‚îÄ Nodes on top ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  for (let sy = 0; sy < FLY_N; sy++) {
    for (let sx = 0; sx < FLY_N; sx++) {
      const nx = MARGIN+sx*STEP, ny = CH-MARGIN-sy*STEP;
      const isFocus = flyFocusNode && sx===flyFocusNode.x && sy===flyFocusNode.y;
      let rho = 0;
      for (let q=0; q<FLY_Q; q++) rho += flyF[flyFidx(sx,sy,q)];
      const rhoT = Math.min((rho-0.8)/1.2, 1);
      if (isFocus) {
        ctx.globalAlpha = 0.3; ctx.fillStyle = '#00d4ff';
        ctx.beginPath(); ctx.arc(nx, ny, NODE_R*2.6, 0, Math.PI*2); ctx.fill();
      }
      ctx.globalAlpha = 1;
      ctx.fillStyle = isFocus ? '#00d4ff'
        : `rgb(${(25+rhoT*90)|0},${(70+rhoT*150)|0},${(110+rhoT*110)|0})`;
      ctx.beginPath(); ctx.arc(nx, ny, NODE_R*(isFocus?1.4:1), 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = isFocus ? 'rgba(0,212,255,0.6)' : 'rgba(30,80,120,0.5)';
      ctx.lineWidth   = isFocus ? 1.5 : 0.5;
      ctx.beginPath(); ctx.arc(nx, ny, NODE_R*(isFocus?1.4:1), 0, Math.PI*2); ctx.stroke();
      ctx.fillStyle    = isFocus ? 'rgba(0,212,255,0.9)' : 'rgba(42,74,106,0.9)';
      ctx.font         = `${(STEP*0.115)|0}px 'Space Mono',monospace`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'top';
      ctx.fillText(`${sx},${sy}`, nx, ny + NODE_R*(isFocus?1.4:1) + 3);
    }
  }
}

// ‚îÄ‚îÄ Main loop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function flyLoop(ts) {
  if (!flyRunning) { flyRAF = null; return; }
  const dt = flyLastTs !== null ? Math.min((ts - flyLastTs) / 1000, 0.1) : 0;
  flyLastTs = ts;
  flyRender(dt);
  flyRAF = requestAnimationFrame(flyLoop);
}

function flyStart() {
  if (flyRAF) return;
  flyLastTs = null;
  flyRAF = requestAnimationFrame(flyLoop);
}

function flyToggle() {
  flyRunning = !flyRunning;
  document.getElementById('flyPauseBtn').textContent = flyRunning ? '‚ñ† PAUSE' : '‚ñ∂ PLAY';
  if (flyRunning) flyStart();
}

function flyClickNode(e) {
  const canvas = document.getElementById('flyCanvas');
  if (!canvas) return;
  const rect   = canvas.getBoundingClientRect();
  const scaleX = canvas.width  / rect.width;
  const scaleY = canvas.height / rect.height;
  const px = (e.clientX - rect.left) * scaleX;
  const py = (e.clientY - rect.top)  * scaleY;
  const CW = canvas.width, CH = canvas.height;
  const MARGIN = CW * 0.12;
  const STEP   = (CW - 2*MARGIN) / (FLY_N - 1);
  let best = null, bestDist = Infinity;
  for (let sy=0; sy<FLY_N; sy++) {
    for (let sx=0; sx<FLY_N; sx++) {
      const nx = MARGIN + sx*STEP, ny = CH - MARGIN - sy*STEP;
      const d  = Math.hypot(px-nx, py-ny);
      if (d < bestDist) { bestDist=d; best={x:sx,y:sy}; }
    }
  }
  if (bestDist < STEP * 0.5) {
    if (flyFocusNode && flyFocusNode.x===best.x && flyFocusNode.y===best.y) flyFocusNode = null;
    else flyFocusNode = best;
    flyUpdateInfoPanel();
  }
}

document.addEventListener('DOMContentLoaded', () => {
  const spd = document.getElementById('flySpeedSlider');
  if (spd) spd.addEventListener('input', e => { flySpeed = parseFloat(e.target.value); });
});

function flyInitIfNeeded() {
  if (flyInitDone) return;
  flyInitDone = true;
  flyInitState();
  flyPrepareWave();
  flyStart();
}

// Called when entering section 4
function scInitIfNeeded() {
  scSetupCanvasClick();
  setTimeout(() => {
    if (!scInitDone) scInit();
    else { scRender(); scUpdateSidePanel(); }
  }, 40);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// LBM SIMULATION ‚Äî D2Q9 BGK / KBC, lid-driven cavity
// Uses "pull" streaming to avoid race conditions.
// Geometry: fluid fills rows 1..NY-2, cols 1..NX-2.
//   y=0      ‚Üí solid bottom wall
//   y=NY-1   ‚Üí solid top wall (lid), moves at uLid in +x
//   x=0,NX-1 ‚Üí solid left/right walls
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let simInitialized = false;
let animId = null;
let running = true;
let step = 0;
let tau = 0.85;
// Collision model: 'bgk' | 'rlbm' | 'clbm'
let collModel = 'bgk';
let uLid = 0.05;

// Grid size (keep modest for JS performance)
const NX = 120, NY = 120;
const Q = 9;

// D2Q9: directions indexed 0‚Äì8
// Convention: ex[i], ey[i] are the velocity components
// opp[i] is the index of the direction exactly opposite to i
const ex  = [ 0,  1,  0, -1,  0,  1, -1, -1,  1];
const ey  = [ 0,  0,  1,  0, -1,  1,  1, -1, -1];
const W   = [4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36];
const opp = [ 0,  3,  4,  1,  2,  7,  8,  5,  6];

// Two buffers: current (f) and post-stream (fS). We swap each step.
// Layout: [y * NX + x] * Q + q   (AoS)
let f  = new Float64Array(NX * NY * Q);
let fS = new Float64Array(NX * NY * Q); // streamed buffer
let rho   = new Float64Array(NX * NY);
let ux    = new Float64Array(NX * NY);
let uy    = new Float64Array(NX * NY);
let solid = new Uint8Array(NX * NY);    // 1 = wall node

const idx  = (x, y)    => y * NX + x;
const fidx = (x, y, q) => (y * NX + x) * Q + q;

// Maxwell-Boltzmann equilibrium, second-order in u
function feq(r, vx, vy, q) {
  const eu = ex[q] * vx + ey[q] * vy;
  const u2 = vx * vx + vy * vy;
  return W[q] * r * (1.0 + 3.0*eu + 4.5*eu*eu - 1.5*u2);
}

// Clamp helper to catch blow-ups early
function isFinitePos(v) { return isFinite(v) && v > 0; }

function initLBM() {
  step = 0;
  for (let y = 0; y < NY; y++) {
    for (let x = 0; x < NX; x++) {
      const i = idx(x, y);
      // Mark walls: bottom, left, right are stationary; top is the moving lid
      solid[i] = (x === 0 || x === NX-1 || y === 0 || y === NY-1) ? 1 : 0;
      rho[i] = 1.0;
      ux[i]  = 0.0;
      uy[i]  = 0.0;
      for (let q = 0; q < Q; q++) {
        f[fidx(x, y, q)] = feq(1.0, 0.0, 0.0, q);
      }
    }
  }
}

function lbmStep() {
  const omega = 1.0 / tau;

  // ‚îÄ‚îÄ STEP 1: PULL STREAMING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Each node pulls distributions from its upstream neighbors.
  // If the upstream neighbor is solid, apply bounce-back (pull from self,
  // but swap direction) ‚Äî this is the "half-way" bounce-back.
  for (let y = 0; y < NY; y++) {
    for (let x = 0; x < NX; x++) {
      const base = (y * NX + x) * Q;
      for (let q = 0; q < Q; q++) {
        const sx = x - ex[q];
        const sy = y - ey[q];

        if (sx < 0 || sx >= NX || sy < 0 || sy >= NY) {
          fS[base + q] = f[base + opp[q]];
        } else if (solid[idx(sx, sy)]) {
          // Upstream neighbor is a wall ‚Üí bounce-back from self, opposite dir
          // For moving lid (top wall, sy === NY-1): add velocity correction
          if (sy === NY-1) {
            const rhoHere = rho[idx(x, y)] || 1.0;
            fS[base + q] = f[(y * NX + x) * Q + opp[q]]
                           + 6.0 * W[q] * rhoHere * (ex[opp[q]] * uLid);
          } else {
            fS[base + q] = f[(y * NX + x) * Q + opp[q]];
          }
        } else {
          fS[base + q] = f[(sy * NX + sx) * Q + q];
        }
      }
    }
  }

  // Swap buffers: fS becomes the new f
  const tmp = f; f = fS; fS = tmp;

  // ‚îÄ‚îÄ STEP 2: COLLISION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  let diverged = false;
  for (let y = 1; y < NY-1; y++) {
    for (let x = 1; x < NX-1; x++) {
      const i = idx(x, y);
      const base = i * Q;

      // Moments (shared by both models)
      let r = 0, mx = 0, my = 0;
      for (let q = 0; q < Q; q++) {
        const fi = f[base + q]; r += fi; mx += ex[q]*fi; my += ey[q]*fi;
      }
      if (!isFinitePos(r)) { diverged = true; break; }
      rho[i] = r;
      ux[i]  = mx / r;
      uy[i]  = my / r;

      if (collModel === 'bgk') {
        // ‚îÄ‚îÄ BGK: single-relaxation-time ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        for (let q = 0; q < Q; q++)
          f[base + q] += omega * (feq(r, ux[i], uy[i], q) - f[base + q]);

      } else if (collModel === 'rlbm') {
        // ‚îÄ‚îÄ Regularised LBM (Latt & Chopard 2006) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        //   Œ†^neq_Œ±Œ≤ = Œ£_i (f_i ‚àí f^eq_i) ¬∑ e_iŒ± ¬∑ e_iŒ≤
        //   f^(1)_i  = W_i ¬∑ (9/2) ¬∑ Q_iŒ±Œ≤ ¬∑ Œ†^neq_Œ±Œ≤
        //   f*_i     = f^eq_i + (1 ‚àí 1/œÑ) ¬∑ f^(1)_i
        let Pxx = 0, Pxy = 0, Pyy = 0;
        for (let q = 0; q < Q; q++) {
          const fneq = f[base + q] - feq(r, ux[i], uy[i], q);
          Pxx += fneq * ex[q] * ex[q];
          Pxy += fneq * ex[q] * ey[q];
          Pyy += fneq * ey[q] * ey[q];
        }
        const coeff = 1.0 - omega;
        for (let q = 0; q < Q; q++) {
          const f1 = W[q] * 4.5 * (
            (ex[q]*ex[q] - 1/3) * Pxx +
             2 * ex[q]*ey[q]    * Pxy +
            (ey[q]*ey[q] - 1/3) * Pyy
          );
          f[base + q] = feq(r, ux[i], uy[i], q) + coeff * f1;
        }

      } else {
        // ‚îÄ‚îÄ Cumulant LBM (Geier, Sch√∂nherr, Pasquali, Krafczyk 2015) ‚îÄ‚îÄ‚îÄ
        //
        // Collision in cumulant space. For D2Q9, 9 cumulants:
        //   K00=œÅ, K10=K01=0 (conserved, moving frame)
        //   K20,K11,K02: 2nd-order stress ‚Üí relax at œâ=1/œÑ (viscosity)
        //   K21,K12:     3rd-order ghost  ‚Üí relax at œâ‚ÇÉ=1 (stability)
        //   K22:         4th-order        ‚Üí relax at œâ‚ÇÑ=1 (Galilean inv.)
        //
        // K22 differs from C22: K22 = C22 ‚àí (C20¬∑C02 + 2¬∑C11¬≤)/œÅ
        // This subtraction removes the factored 2nd-order product,
        // giving a ZERO equilibrium K22 and exact Galilean invariance.
        //
        // Back-transform uses the analytic D2Q9 inverse moment matrix
        // (precomputed) ‚Äî no matrix multiply needed at runtime.

        // ‚îÄ‚îÄ Forward: raw moments ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const k20 = f[base+1]+f[base+3]+f[base+5]+f[base+6]+f[base+7]+f[base+8];
        const k02 = f[base+2]+f[base+4]+f[base+5]+f[base+6]+f[base+7]+f[base+8];
        const k11 = f[base+5]-f[base+6]+f[base+7]-f[base+8];
        const k21 = f[base+5]-f[base+6]-f[base+7]+f[base+8]
                  + f[base+1]+f[base+3];  // ex^2*ey non-zero only for axial+diag
        // Actually must compute properly from all 9:
        // k21 = sum f_i * ex_i^2 * ey_i
        // ex^2*ey: idx0=0,1=0,2=0,3=0,4=0,5=1*1,6=1*1,7=1*(-1),8=1*(-1) ‚Äî wait
        // ex[5]=1,ey[5]=1 ‚Üí ex^2*ey=1; ex[6]=-1,ey[6]=1‚Üí1; ex[7]=-1,ey[7]=-1‚Üí-1; ex[8]=1,ey[8]=-1‚Üí-1
        // So k21 = f[5]+f[6]-f[7]-f[8]  ... but also axial: ex[2]=0‚Üí0, ex[1]=1,ey[1]=0‚Üí0
        // Only diagonals contribute to k21! k21 = f[5]+f[6]-f[7]-f[8]
        // Let me verify: and k12 = f[5]-f[6]-f[7]+f[8] (only diagonals)

        // Recompute raw moments correctly using explicit index arithmetic
        const K20_ = f[base+1]+f[base+3]
                   + f[base+5]+f[base+6]+f[base+7]+f[base+8];  // ex^2=1 for i=1,3,5,6,7,8
        const K02_ = f[base+2]+f[base+4]
                   + f[base+5]+f[base+6]+f[base+7]+f[base+8];  // ey^2=1 for i=2,4,5,6,7,8
        const K11_ = f[base+5]-f[base+6]+f[base+7]-f[base+8];  // ex*ey: +1,-1,+1,-1 for 5,6,7,8; 0 for others
        // Wait: ex[5]=1,ey[5]=1‚Üí+1; ex[6]=-1,ey[6]=1‚Üí-1; ex[7]=-1,ey[7]=-1‚Üí+1; ex[8]=1,ey[8]=-1‚Üí-1
        const K21_ = f[base+5]+f[base+6]-f[base+7]-f[base+8];  // ex^2*ey: 1,1,-1,-1
        const K12_ = f[base+5]-f[base+6]-f[base+7]+f[base+8];  // ex*ey^2: 1,-1,-1,+1
        // ex[5]*ey[5]^2=1*1=1; ex[6]*ey[6]^2=(-1)*1=-1; ex[7]*ey[7]^2=(-1)*1=-1; ex[8]*ey[8]^2=1*1=1
        const K22_ = f[base+5]+f[base+6]+f[base+7]+f[base+8];  // ex^2*ey^2=1 only for diagonals

        // ‚îÄ‚îÄ Central moments ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const ux2 = ux[i]*ux[i], uy2 = uy[i]*uy[i], uxuy = ux[i]*uy[i];
        const C20 = K20_ - r*ux2;
        const C11 = K11_ - r*uxuy;
        const C02 = K02_ - r*uy2;
        const C21 = K21_ - 2*K11_*ux[i] - K20_*uy[i] + 2*r*ux2*uy[i];
        const C12 = K12_ - 2*K11_*uy[i] - K02_*ux[i] + 2*r*uy2*ux[i];
        const C22 = K22_ - 2*ux[i]*K12_ - 2*uy[i]*K21_
                  + ux2*K02_ + 4*uxuy*K11_ + uy2*K20_ - 3*r*ux2*uy2;

        // ‚îÄ‚îÄ Cumulant (only K22 differs) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const invR = 1.0 / r;
        const kappa22 = C22 - (C20*C02 + 2*C11*C11) * invR;

        // ‚îÄ‚îÄ Relax ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const cs2r  = r / 3.0;                    // cs¬≤¬∑œÅ
        const omC   = 1.0 - omega;               // (1 - œâ) factor for stress
        const C20n  = cs2r + omC * (C20 - cs2r); // = C20 + œâ*(cs¬≤œÅ - C20)
        const C11n  = omC * C11;                  // = C11 + œâ*(0 - C11)
        const C02n  = cs2r + omC * (C02 - cs2r);
        // Ghost modes: œâ‚ÇÉ=1 ‚Üí full relaxation to 0
        // (1 - œâ‚ÇÉ)*C21 = 0, so C21n=0, C12n=0
        // K22: œâ‚ÇÑ=1 ‚Üí kappa22n = 0
        // C22n = K22n + (C20n*C02n + 2*C11n¬≤)/œÅ
        const C22n = (C20n*C02n + 2*C11n*C11n) * invR;  // K22n=0 term vanishes

        // ‚îÄ‚îÄ Back to raw moments ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const k20n = C20n + r*ux2;
        const k11n = C11n + r*uxuy;
        const k02n = C02n + r*uy2;
        // C21n=C12n=0 ‚Üí k21n and k12n simplify:
        const k21n = 2*C11n*ux[i] + C20n*uy[i] + r*ux2*uy[i];
        const k12n = 2*C11n*uy[i] + C02n*ux[i] + r*uy2*ux[i];
        const k22n = C22n + 2*ux[i]*k12n + 2*uy[i]*k21n
                   - ux2*k02n - 4*uxuy*k11n - uy2*k20n + 3*r*ux2*uy2;

        // ‚îÄ‚îÄ Reconstruct f* from D2Q9 analytic Minv ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // f[0] = œÅ ‚àí k20 ‚àí k02 + k22
        // f[1] = ¬Ω(jx + k20 ‚àí k12 ‚àí k22)
        // f[2] = ¬Ω(jy + k02 ‚àí k21 ‚àí k22)
        // f[3] = ¬Ω(‚àíjx + k20 + k12 ‚àí k22)
        // f[4] = ¬Ω(‚àíjy + k02 + k21 ‚àí k22)
        // f[5] = ¬º(k11 + k21 + k12 + k22)
        // f[6] = ¬º(‚àík11 + k21 ‚àí k12 + k22)
        // f[7] = ¬º(k11 ‚àí k21 ‚àí k12 + k22)
        // f[8] = ¬º(‚àík11 ‚àí k21 + k12 + k22)
        const jx_ = r*ux[i], jy_ = r*uy[i];
        f[base+0] = r    - k20n - k02n + k22n;
        f[base+1] = 0.5*( jx_ + k20n - k12n - k22n);
        f[base+2] = 0.5*( jy_ + k02n - k21n - k22n);
        f[base+3] = 0.5*(-jx_ + k20n + k12n - k22n);
        f[base+4] = 0.5*(-jy_ + k02n + k21n - k22n);
        f[base+5] = 0.25*( k11n + k21n + k12n + k22n);
        f[base+6] = 0.25*(-k11n + k21n - k12n + k22n);
        f[base+7] = 0.25*( k11n - k21n - k12n + k22n);
        f[base+8] = 0.25*(-k11n - k21n + k12n + k22n);
      }
    }
    if (diverged) break;
  }

  // If simulation has blown up, quietly reset
  if (diverged) {
    console.warn('LBM: numerical instability detected ‚Äî resetting.');
    initLBM();
  }
}

// Jet colormap: 0‚Üíblue, 0.5‚Üígreen, 1‚Üíred
function velColor(t) {
  t = Math.max(0, Math.min(1, t));
  let r, g, b;
  if (t < 0.25)      { r = 0;            g = t * 4;          b = 1; }
  else if (t < 0.5)  { r = 0;            g = 1;              b = 1 - (t - 0.25) * 4; }
  else if (t < 0.75) { r = (t - 0.5)*4; g = 1;              b = 0; }
  else               { r = 1;            g = 1-(t-0.75)*4;   b = 0; }
  return [r * 255 | 0, g * 255 | 0, b * 255 | 0];
}

// Diverging colormap: blue(negative) ‚Üí white(zero) ‚Üí red(positive)
function divColor(t) {
  // t in [-1, 1]
  const c = Math.max(-1, Math.min(1, t));
  if (c < 0) { const s = -c; return [Math.round(255*(1-s)), Math.round(255*(1-s)), 255]; }
  else        { const s =  c; return [255, Math.round(255*(1-s)), Math.round(255*(1-s))]; }
}

function render() {
  const canvas = document.getElementById('lbmCanvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const W2 = canvas.width, H2 = canvas.height;
  const idata = ctx.createImageData(NX, NY);
  const data  = idata.data;

  // Normalisation: compute per-mode range
  let maxSpd = 1e-9, minRho = 1e9, maxRho = -1e9, maxUx = 1e-9, maxUy = 1e-9, maxVort = 1e-9;
  for (let y = 1; y < NY-1; y++) {
    for (let x = 1; x < NX-1; x++) {
      const i = idx(x, y);
      const spd = Math.sqrt(ux[i]*ux[i] + uy[i]*uy[i]);
      if (spd > maxSpd) maxSpd = spd;
      if (rho[i] < minRho) minRho = rho[i];
      if (rho[i] > maxRho) maxRho = rho[i];
      if (Math.abs(ux[i]) > maxUx) maxUx = Math.abs(ux[i]);
      if (Math.abs(uy[i]) > maxUy) maxUy = Math.abs(uy[i]);
      const xm=Math.max(x-1,0),xp=Math.min(x+1,NX-1),ym=Math.max(y-1,0),yp=Math.min(y+1,NY-1);
      const v=Math.abs((uy[idx(xp,y)]-uy[idx(xm,y)])*0.5-(ux[idx(x,yp)]-ux[idx(x,ym)])*0.5);
      if(v>maxVort) maxVort=v;
    }
  }
  const rhoMid = (minRho + maxRho) / 2;
  const rhoRange = Math.max(maxRho - minRho, 1e-9) / 2;

  for (let y = 0; y < NY; y++) {
    for (let x = 0; x < NX; x++) {
      const i   = idx(x, y);
      const px  = (NY - 1 - y) * NX + x; // flip y so y=0 is bottom
      const off = px * 4;

      if (y === NY-1) {
        data[off]=80; data[off+1]=200; data[off+2]=255; data[off+3]=255;
      } else if (solid[i]) {
        data[off]=50; data[off+1]=70; data[off+2]=90; data[off+3]=255;
      } else {
        let r, g, b;
        if (vizMode === 0) {
          const spd = Math.sqrt(ux[i]*ux[i] + uy[i]*uy[i]);
          [r, g, b] = velColor(spd / maxSpd);
        } else if (vizMode === 1) {
          [r, g, b] = divColor((rho[i] - rhoMid) / rhoRange);
        } else if (vizMode === 2) {
          [r, g, b] = divColor(ux[i] / maxUx);
        } else if (vizMode === 3) {
          [r, g, b] = divColor(uy[i] / maxUy);
        } else {
          // Vorticity œâz = ‚àÇuy/‚àÇx ‚àí ‚àÇux/‚àÇy
          const xm=Math.max(x-1,0),xp=Math.min(x+1,NX-1),ym=Math.max(y-1,0),yp=Math.min(y+1,NY-1);
          const vort=(uy[idx(xp,y)]-uy[idx(xm,y)])*0.5-(ux[idx(x,yp)]-ux[idx(x,ym)])*0.5;
          [r, g, b] = divColor(vort / (maxVort||1e-9));
        }
        data[off]=r; data[off+1]=g; data[off+2]=b; data[off+3]=255;
      }
    }
  }

  // Write 120√ó120 pixel image to an offscreen canvas, then stretch to fill display canvas
  const offscreen = document.createElement('canvas');
  offscreen.width  = NX;
  offscreen.height = NY;
  offscreen.getContext('2d').putImageData(idata, 0, 0);
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(offscreen, 0, 0, W2, H2);

  // Arrow overlay (optional, toggled by ARROWS button)
  if (showArrows) {
    const STEP = Math.max(Math.round(NX / 14), 6);
    const scaleX = W2 / NX;
    const scaleY = H2 / NY;
    const arrowLen = scaleX * STEP * 0.55;
    let maxSpd2 = 1e-9;
    for (let y = STEP; y < NY - STEP; y += STEP)
      for (let x = STEP; x < NX - STEP; x += STEP) {
        const spd = Math.sqrt(ux[idx(x,y)]**2 + uy[idx(x,y)]**2);
        if (spd > maxSpd2) maxSpd2 = spd;
      }
    for (let y = STEP; y < NY - STEP; y += STEP) {
      for (let x = STEP; x < NX - STEP; x += STEP) {
        const i   = idx(x, y);
        if (solid[i]) continue;
        const spd = Math.sqrt(ux[i]*ux[i] + uy[i]*uy[i]);
        if (spd < 1e-7) continue;
        const norm   = Math.min(spd / maxSpd2, 1);
        const cx     = (x + 0.5) * scaleX;
        const cy     = (NY - y - 0.5) * scaleY;
        const dx     = (ux[i] / spd) * norm * arrowLen;
        const dy     = -(uy[i] / spd) * norm * arrowLen; // flip y
        const tipX   = cx + dx;
        const tipY   = cy + dy;
        // Alpha scales with speed for visual clarity
        const alpha  = 0.35 + 0.65 * norm;
        ctx.strokeStyle = `rgba(255,255,255,${alpha.toFixed(2)})`;
        ctx.lineWidth   = 1.0 + norm * 1.2;
        ctx.beginPath();
        ctx.moveTo(cx - dx * 0.35, cy - dy * 0.35); // centre the arrow on the grid point
        ctx.lineTo(tipX, tipY);
        ctx.stroke();
        // Arrowhead
        const headLen = 4 + norm * 4;
        const angle   = Math.atan2(dy, dx);
        ctx.beginPath();
        ctx.moveTo(tipX, tipY);
        ctx.lineTo(tipX - headLen * Math.cos(angle - 0.4), tipY - headLen * Math.sin(angle - 0.4));
        ctx.lineTo(tipX - headLen * Math.cos(angle + 0.4), tipY - headLen * Math.sin(angle + 0.4));
        ctx.closePath();
        ctx.fillStyle = `rgba(255,255,255,${alpha.toFixed(2)})`;
        ctx.fill();
      }
    }
  }

  // Mode label overlay (drawn at canvas resolution)
  const modeNames = ['|u| velocity', 'density œÅ', 'u_x velocity', 'u_y velocity', 'vorticity œâz'];
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  ctx.fillRect(8, 8, 160, 26);
  ctx.fillStyle = '#e8f4ff';
  ctx.font = '13px "Space Mono", monospace';
  ctx.fillText(modeNames[vizMode], 14, 26);
}

const STEPS_PER_FRAME = 6;

function simLoop() {
  if (running) {
    for (let s = 0; s < STEPS_PER_FRAME; s++) {
      lbmStep();
      step++;
    }
    render();
    document.getElementById('stepVal').textContent = step;
    // Re = u * L / ŒΩ,  ŒΩ = (1/3)*(œÑ - 0.5)
    const nu = (1/3) * (tau - 0.5);
    const re = (uLid * (NY - 2)) / nu;
    document.getElementById('reVal').textContent = re.toFixed(0);
  }
  animId = requestAnimationFrame(simLoop);
}

function initSim() {
  if (simInitialized) return;
  simInitialized = true;
  updateModelUI();
  initLBM();
  simLoop();
}

function toggleSim() {
  running = !running;
  document.getElementById('playBtn').textContent = running ? '‚ñ† PAUSE' : '‚ñ∂ PLAY';
}

function resetSim() {
  initLBM();
  step = 0;
}

let vizMode = 0; // 0=velocity, 1=density, 2=ux, 3=uy
let showArrows = false;
const vizModeLabels = ['MODE: VELOCITY', 'MODE: DENSITY', 'MODE: U‚Çì', 'MODE: U·µß'];

function toggleMode() {
  vizMode = (vizMode + 1) % 5;
  document.getElementById('modeBtn').textContent = vizModeLabels[vizMode];
}

function toggleArrows() {
  showArrows = !showArrows;
  const btn = document.getElementById('arrowBtn');
  btn.textContent = showArrows ? 'ARROWS: ON' : 'ARROWS: OFF';
  btn.style.borderColor = showArrows ? '#4ade80' : '#4ade80';
  btn.style.color       = showArrows ? '#ffffff'  : '#4ade80';
  btn.style.background  = showArrows ? '#166534'  : '';
}

function updateTau(v) {
  tau = parseFloat(v);
  const re = (uLid * (NX-2)) / (1/3 * (tau - 0.5));
  document.getElementById('tauVal').textContent = 'œÑ = ' + tau.toFixed(3);
  document.getElementById('reVal').textContent  = re.toFixed(0);
}

function toggleModel() {
  // Cycle: bgk ‚Üí rlbm ‚Üí clbm ‚Üí bgk
  collModel = collModel === 'bgk' ? 'rlbm' : collModel === 'rlbm' ? 'clbm' : 'bgk';
  updateModelUI();
  initLBM();
}

function updateModelUI() {
  const btn    = document.getElementById('modelBtn');
  const slider = document.getElementById('tauSlider');
  const hint   = document.getElementById('simHint');

  const labels = { bgk: 'MODEL: BGK', rlbm: 'MODEL: RLBM', clbm: 'MODEL: CLBM' };
  const colors = { bgk: 'var(--accent2)', rlbm: '#a78bfa', clbm: '#34d399' };
  const hints  = {
    bgk:  '‚Üë <strong>BGK</strong>: simple and accurate at moderate Re, but diverges below &tau; &approx; 0.53.',
    rlbm: '‚Üë <strong>RLBM</strong>: stable down to &tau; = 0.501 by filtering ghost modes. Small artefacts possible at high &tau;.',
    clbm: '‚Üë <strong>Cumulant LBM</strong>: collision in cumulant space ‚Äî stable, Galilean invariant, and artefact-free. Best accuracy at all Re.'
  };

  if (btn) {
    btn.textContent       = labels[collModel];
    btn.style.borderColor = colors[collModel];
    btn.style.color       = colors[collModel];
  }
  if (slider) {
    slider.min = (collModel === 'bgk') ? '0.52' : '0.501';
    if (collModel === 'bgk' && parseFloat(slider.value) < 0.52) {
      slider.value = '0.52'; updateTau('0.52');
    }
  }
  if (hint) hint.innerHTML = hints[collModel];
}

function updateU(v) {
  uLid = parseFloat(v);
  const re = (uLid * (NX-2)) / (1/3 * (tau - 0.5));
  document.getElementById('uVal').textContent = 'u = ' + uLid.toFixed(3);
  document.getElementById('reVal').textContent = re.toFixed(0);
}
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// K√ÅRM√ÅN VORTEX STREET  ‚Äî  flow past a circular cylinder
// Wide channel NKX √ó NKY, Zou-He velocity inlet, open outlet,
// bounce-back top/bottom walls and cylinder surface.
// All D2Q9 constants (ex, ey, W, opp, feq, velColor, divColor)
// are shared with the cavity solver above.
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const NKX = 360, NKY = 150;   // 2.4:1 matches canvas aspect ratio
const KQ  = 9;

// Cylinder geometry (placed at ~22% from left, vertically centred)
const KCX = Math.floor(NKX * 0.22);
const KCY = Math.floor(NKY * 0.50) + 2;  // slight offset breaks y-symmetry permanently
const KCR = Math.floor(NKY * 0.091);  // radius ‚âà 9.1% channel height ‚Üí D ‚âà 18% (30% smaller)

// Simulation state
let kf   = new Float64Array(NKX * NKY * KQ);
let kfS  = new Float64Array(NKX * NKY * KQ);
let krho = new Float64Array(NKX * NKY);
let kux  = new Float64Array(NKX * NKY);
let kuy  = new Float64Array(NKX * NKY);
let ksolid = new Uint8Array(NKX * NKY);   // 1 = solid (cylinder or wall)

let kvTau       = 0.56;
let kvU         = 0.07;
let kvStep      = 0;
let kvRunning   = false;
let kvInitDone  = false;
let kvAnimId    = null;
let kvCollModel = 'bgk';
let kvVizMode   = 0;
let kvShowArrows = false;

const kidx = (x, y) => y * NKX + x;

// Equilibrium reuses cavity's feq / W / ex / ey / opp

// ‚îÄ‚îÄ Geometry: mark walls and cylinder ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function kvBuildSolid() {
  for (let y = 0; y < NKY; y++) {
    for (let x = 0; x < NKX; x++) {
      const dx = x - KCX, dy = y - KCY;
      // Top/bottom are NOT walls ‚Äî periodic BC handles them instead
      ksolid[kidx(x, y)] =
        (dx * dx + dy * dy <= KCR * KCR) ? 1 : 0;
    }
  }
}

// ‚îÄ‚îÄ Initialise distributions: uniform inflow + small y-perturbation ‚îÄ‚îÄ
function kvInitLBM() {
  kvStep = 0;
  kvBuildSolid();
  for (let y = 0; y < NKY; y++) {
    for (let x = 0; x < NKX; x++) {
      const i   = kidx(x, y);
      const sol = ksolid[i];
      // Strong initial vy perturbation across the whole field to seed shedding.
      // Multi-mode sine so the wake picks up the instability quickly regardless
      // of cylinder position. Amplitude ~15% of kvU ‚Äî decays within ~100 steps
      // but is enough to break symmetry reliably.
      const dx = x - KCX, dy = y - KCY;
      const distR = Math.sqrt(dx*dx + dy*dy) / KCR;
      // Stronger near and behind the cylinder, zero inside
      const envelope = sol ? 0 : Math.exp(-0.5 * Math.max(0, distR - 1));
      // sin(œÄ*y/NKY) peaks at cylinder centerline (y=NKY/2) ‚Äî where it matters most
      const pert = envelope * kvU * 0.3 * (
        Math.sin(Math.PI * y / NKY) - 0.5
      );
      const vx0 = sol ? 0 : kvU;
      const vy0 = sol ? 0 : pert;
      krho[i] = 1.0;
      kux[i]  = vx0;
      kuy[i]  = vy0;
      const base = i * KQ;
      for (let q = 0; q < KQ; q++)
        kf[base + q] = feq(1.0, vx0, vy0, q);
    }
  }
}

// ‚îÄ‚îÄ One LBM time step ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Streaming convention: PULL (each node pulls from upstream neighbor).
// Boundary conditions:
//   Left  (x=0): equilibrium inflow ‚Äî all f_i = feq(1, kvU, 0, q)
//   Right (x=NKX-1): Neumann outflow ‚Äî copy f from x=NKX-2 (zero gradient)
//   Top/Bottom (y=0, y=NKY-1): wall nodes, skipped (solid)
//   Cylinder:   half-way bounce-back (pull opposite direction from same node)
function kvLbmStep() {
  const omega = 1.0 / kvTau;

  // ‚îÄ‚îÄ STEP 1: PULL STREAMING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  for (let y = 0; y < NKY; y++) {
    for (let x = 0; x < NKX; x++) {
      const base = kidx(x, y) * KQ;

      // Solid nodes don't stream (their f stays irrelevant ‚Äî skipped in collision)
      if (ksolid[kidx(x, y)]) {
        for (let q = 0; q < KQ; q++) kfS[base+q] = kf[base+q];
        continue;
      }

      for (let q = 0; q < KQ; q++) {
        const sx = x - ex[q];
        const sy = y - ey[q];

        if (sx < 0) {
          // Only rightward dirs (q=1,5,8) have sx<0 at x=0.
          // Placeholder ‚Äî Zou-He overwrites these correctly below.
          kfS[base+q] = feq(1.0, kvU, 0.0, q);
        } else if (sx >= NKX) {
          // Outflow (Neumann): copy from one node upstream
          kfS[base+q] = kf[kidx(NKX-2, y)*KQ + q];
        } else {
          // Periodic BC top/bottom: wrap sy
          const syw = (sy + NKY) % NKY;
          if (ksolid[kidx(sx, syw)]) {
            // Cylinder surface: half-way bounce-back
            kfS[base+q] = kf[base + opp[q]];
          } else {
            // Normal interior streaming (including periodic wrap)
            kfS[base+q] = kf[kidx(sx, syw)*KQ + q];
          }
        }
      }
    }
  }

  // Swap buffers
  { const tmp = kf; kf = kfS; kfS = tmp; }

  // ‚îÄ‚îÄ STEP 2: ZOU-HE VELOCITY INLET (x=0) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Only the 3 rightward populations (q=1,5,8) are unknown after streaming.
  // q=3,6,7 arrived from x=1 (interior) and carry physical pressure info.
  // rho is derived from the 6 known populations so momentum is consistent.
  // A small persistent vy perturbation seeds the shedding instability.
  for (let y = 0; y < NKY; y++) {
    if (ksolid[kidx(0, y)]) continue;
    const base = kidx(0, y) * KQ;
    const vyIn = kvU * 0.03 * Math.sin(Math.PI * y / NKY - Math.PI * 0.5);  // peaks at cylinder centerline

    // Zou-He: rho from known populations (ex <= 0)
    // known: q=0(ex=0), q=2(ex=0), q=4(ex=0), q=3(ex=-1), q=6(ex=-1), q=7(ex=-1)
    const r = (kf[base+0] + kf[base+2] + kf[base+4]
             + 2.0*(kf[base+3] + kf[base+6] + kf[base+7])) / (1.0 - kvU);

    // vy imbalance from the ex=0 populations
    const jydiff = (kf[base+2] - kf[base+4]);

    // Set only the 3 unknown rightward populations
    kf[base+1] = kf[base+3] + (2.0/3.0)*r*kvU;
    kf[base+5] = kf[base+7] + (1.0/6.0)*r*kvU + 0.5*jydiff + 0.5*r*vyIn;
    kf[base+8] = kf[base+6] + (1.0/6.0)*r*kvU - 0.5*jydiff - 0.5*r*vyIn;

    krho[kidx(0,y)] = r;
    kux [kidx(0,y)] = kvU;
    kuy [kidx(0,y)] = (kf[base+2]-kf[base+4]+kf[base+5]-kf[base+7]+kf[base+6]-kf[base+8]+(kf[base+5]+kf[base+8]-kf[base+6]-kf[base+7]))/r;
  }

  // ‚îÄ‚îÄ STEP 3: COLLISION (all fluid nodes including outflow column) ‚îÄ‚îÄ
  let diverged = false;
  for (let y = 0; y < NKY; y++) {
    for (let x = 1; x < NKX; x++) {   // start at x=1 (x=0 already set above)
      const i = kidx(x, y);
      if (ksolid[i]) continue;
      const base = i * KQ;

      let r = 0, mx = 0, my = 0;
      for (let q = 0; q < KQ; q++) {
        const fi = kf[base+q]; r += fi; mx += ex[q]*fi; my += ey[q]*fi;
      }
      if (!isFinite(r) || r <= 0 || r > 3.0) { diverged = true; break; }
      krho[i] = r; kux[i] = mx/r; kuy[i] = my/r;

      if (kvCollModel === 'bgk') {
        for (let q = 0; q < KQ; q++)
          kf[base+q] += omega*(feq(r, kux[i], kuy[i], q) - kf[base+q]);

      } else if (kvCollModel === 'rlbm') {
        let Pxx=0, Pxy=0, Pyy=0;
        for (let q = 0; q < KQ; q++) {
          const fn = kf[base+q] - feq(r, kux[i], kuy[i], q);
          Pxx+=fn*ex[q]*ex[q]; Pxy+=fn*ex[q]*ey[q]; Pyy+=fn*ey[q]*ey[q];
        }
        const c1 = 1.0 - omega;
        for (let q = 0; q < KQ; q++) {
          const f1 = W[q]*4.5*((ex[q]*ex[q]-1/3)*Pxx + 2*ex[q]*ey[q]*Pxy + (ey[q]*ey[q]-1/3)*Pyy);
          kf[base+q] = feq(r, kux[i], kuy[i], q) + c1*f1;
        }

      } else {
        // Cumulant LBM
        const K20_=kf[base+1]+kf[base+3]+kf[base+5]+kf[base+6]+kf[base+7]+kf[base+8];
        const K02_=kf[base+2]+kf[base+4]+kf[base+5]+kf[base+6]+kf[base+7]+kf[base+8];
        const K11_=kf[base+5]-kf[base+6]+kf[base+7]-kf[base+8];
        const K21_=kf[base+5]+kf[base+6]-kf[base+7]-kf[base+8];
        const K12_=kf[base+5]-kf[base+6]-kf[base+7]+kf[base+8];
        const K22_=kf[base+5]+kf[base+6]+kf[base+7]+kf[base+8];
        const ux2=kux[i]*kux[i], uy2=kuy[i]*kuy[i], uxuy=kux[i]*kuy[i];
        const C20=K20_-r*ux2, C11=K11_-r*uxuy, C02=K02_-r*uy2;
        const C22=K22_-2*kux[i]*K12_-2*kuy[i]*K21_+ux2*K02_+4*uxuy*K11_+uy2*K20_-3*r*ux2*uy2;
        const iR=1/r, cs2r=r/3, omC=1-omega;
        const C20n=cs2r+omC*(C20-cs2r), C11n=omC*C11, C02n=cs2r+omC*(C02-cs2r);
        const C22n=(C20n*C02n+2*C11n*C11n)*iR;
        const k20n=C20n+r*ux2, k11n=C11n+r*uxuy, k02n=C02n+r*uy2;
        const k21n=2*C11n*kux[i]+C20n*kuy[i]+r*ux2*kuy[i];
        const k12n=2*C11n*kuy[i]+C02n*kux[i]+r*uy2*kux[i];
        const k22n=C22n+2*kux[i]*k12n+2*kuy[i]*k21n-ux2*k02n-4*uxuy*k11n-uy2*k20n+3*r*ux2*uy2;
        const jx_=r*kux[i], jy_=r*kuy[i];
        kf[base+0]=r-k20n-k02n+k22n;
        kf[base+1]=0.5*( jx_+k20n-k12n-k22n);
        kf[base+2]=0.5*( jy_+k02n-k21n-k22n);
        kf[base+3]=0.5*(-jx_+k20n+k12n-k22n);
        kf[base+4]=0.5*(-jy_+k02n+k21n-k22n);
        kf[base+5]=0.25*( k11n+k21n+k12n+k22n);
        kf[base+6]=0.25*(-k11n+k21n-k12n+k22n);
        kf[base+7]=0.25*( k11n-k21n-k12n+k22n);
        kf[base+8]=0.25*(-k11n-k21n+k12n+k22n);
      }


    }
    if (diverged) break;
  }
  if (diverged) { console.warn('K√°rm√°n LBM: diverged ‚Äî resetting'); kvInitLBM(); }
}

// ‚îÄ‚îÄ Render ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function kvRender() {
  const canvas = document.getElementById('kvCanvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const CW = canvas.width, CH = canvas.height;

  // Per-mode normalisation range
  let maxSpd=1e-9, minRho=1e9, maxRho=-1e9, maxKUx=1e-9, maxKUy=1e-9, maxKVort=1e-9;
  for (let y=0; y<NKY; y++) for (let x=0; x<NKX; x++) {
    const i=kidx(x,y); if(ksolid[i]) continue;
    const s=Math.sqrt(kux[i]*kux[i]+kuy[i]*kuy[i]);
    if(s>maxSpd) maxSpd=s;
    if(krho[i]<minRho) minRho=krho[i]; if(krho[i]>maxRho) maxRho=krho[i];
    if(Math.abs(kux[i])>maxKUx) maxKUx=Math.abs(kux[i]);
    if(Math.abs(kuy[i])>maxKUy) maxKUy=Math.abs(kuy[i]);
    const xm=Math.max(x-1,0),xp=Math.min(x+1,NKX-1),ym=(y-1+NKY)%NKY,yp=(y+1)%NKY;
    const v=Math.abs((kuy[kidx(xp,y)]-kuy[kidx(xm,y)])*0.5-(kux[kidx(x,yp)]-kux[kidx(x,ym)])*0.5);
    if(v>maxKVort) maxKVort=v;
  }
  const rhoMid=(minRho+maxRho)/2, rhoRange=Math.max(maxRho-minRho,1e-9)/2;

  const idata = ctx.createImageData(NKX, NKY);
  const data  = idata.data;
  for (let y=0; y<NKY; y++) {
    for (let x=0; x<NKX; x++) {
      const i   = kidx(x, y);
      const px  = (NKY-1-y)*NKX + x;   // flip y: LBM y=0 is bottom
      const off = px * 4;
      if (ksolid[i]) {
        data[off]=170; data[off+1]=178; data[off+2]=190; data[off+3]=255;
      } else {
        let r, g, b;
        if      (kvVizMode===0) [r,g,b]=velColor(Math.sqrt(kux[i]*kux[i]+kuy[i]*kuy[i])/maxSpd);
        else if (kvVizMode===1) [r,g,b]=divColor((krho[i]-rhoMid)/rhoRange);
        else if (kvVizMode===2) [r,g,b]=divColor(kux[i]/maxKUx);
        else if (kvVizMode===3) [r,g,b]=divColor(kuy[i]/(maxKUy||1e-9));
        else {
          // Vorticity œâz = ‚àÇuy/‚àÇx ‚àí ‚àÇux/‚àÇy, periodic in y
          const xm=Math.max(x-1,0),xp=Math.min(x+1,NKX-1),ym=(y-1+NKY)%NKY,yp=(y+1)%NKY;
          const vort=(kuy[kidx(xp,y)]-kuy[kidx(xm,y)])*0.5-(kux[kidx(x,yp)]-kux[kidx(x,ym)])*0.5;
          [r,g,b]=divColor(vort/(maxKVort||1e-9));
        }
        data[off]=r; data[off+1]=g; data[off+2]=b; data[off+3]=255;
      }
    }
  }

  // Stretch 360√ó150 pixel buffer ‚Üí full canvas via offscreen canvas
  const offsc = document.createElement('canvas');
  offsc.width=NKX; offsc.height=NKY;
  offsc.getContext('2d').putImageData(idata,0,0);
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(offsc, 0, 0, CW, CH);

  // Optional arrow overlay
  if (kvShowArrows) {
    const STEP  = Math.max(Math.round(NKY/10), 5);
    const scX   = CW/NKX, scY = CH/NKY;
    const aLen  = scX * STEP * 0.5;
    let ms2 = 1e-9;
    for (let y=STEP; y<NKY-STEP; y+=STEP)
      for (let x=STEP; x<NKX-STEP; x+=STEP) {
        const s=Math.sqrt(kux[kidx(x,y)]**2+kuy[kidx(x,y)]**2);
        if(s>ms2) ms2=s;
      }
    for (let y=STEP; y<NKY-STEP; y+=STEP) {
      for (let x=STEP; x<NKX-STEP; x+=STEP) {
        const i=kidx(x,y); if(ksolid[i]) continue;
        const s=Math.sqrt(kux[i]*kux[i]+kuy[i]*kuy[i]); if(s<1e-7) continue;
        const norm=Math.min(s/ms2,1);
        const cx=(x+.5)*scX, cy=(NKY-y-.5)*scY;
        const dx=(kux[i]/s)*norm*aLen, dy=-(kuy[i]/s)*norm*aLen;
        const alpha=0.35+0.65*norm;
        ctx.strokeStyle=`rgba(255,255,255,${alpha.toFixed(2)})`;
        ctx.lineWidth=0.8+norm*1.2;
        ctx.beginPath();
        ctx.moveTo(cx-dx*0.3, cy-dy*0.3);
        ctx.lineTo(cx+dx, cy+dy);
        ctx.stroke();
        const hL=3+norm*4, ang=Math.atan2(dy,dx);
        ctx.beginPath();
        ctx.moveTo(cx+dx, cy+dy);
        ctx.lineTo(cx+dx-hL*Math.cos(ang-0.4), cy+dy-hL*Math.sin(ang-0.4));
        ctx.lineTo(cx+dx-hL*Math.cos(ang+0.4), cy+dy-hL*Math.sin(ang+0.4));
        ctx.closePath();
        ctx.fillStyle=`rgba(255,255,255,${alpha.toFixed(2)})`; ctx.fill();
      }
    }
  }

  // Mode label
  const kvModeNames=['|u| velocity','density œÅ','u_x velocity','u_y velocity','vorticity œâz'];
  ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(8,8,162,26);
  ctx.fillStyle='#e8f4ff'; ctx.font='13px "Space Mono",monospace';
  ctx.fillText(kvModeNames[kvVizMode], 14, 26);
}

// ‚îÄ‚îÄ Simulation loop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const KV_SPF = 10;   // LBM steps per animation frame

function kvSimLoop() {
  if (kvRunning) {
    for (let s=0; s<KV_SPF; s++) { kvLbmStep(); kvStep++; }
    kvRender();
    document.getElementById('kvStepVal').textContent = kvStep;
    const nu = (1/3)*(kvTau-0.5);
    document.getElementById('kvReVal').textContent = ((kvU*2*KCR)/nu).toFixed(0);
  }
  kvAnimId = requestAnimationFrame(kvSimLoop);
}

function initKarman() {
  if (kvInitDone) return;
  kvInitDone = true;
  kvUpdateModelUI();
  kvInitLBM();
  kvRunning = true;
  kvSimLoop();
}

// ‚îÄ‚îÄ Controls ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function kvToggleSim() {
  kvRunning = !kvRunning;
  document.getElementById('kvPlayBtn').textContent = kvRunning ? '‚ñ† PAUSE' : '‚ñ∂ PLAY';
}
function kvResetSim() { kvInitLBM(); kvStep=0; }

const kvVizLabels = ['MODE: VELOCITY','MODE: DENSITY','MODE: U‚Çì','MODE: U·µß','MODE: VORTICITY'];
function kvToggleMode() {
  kvVizMode = (kvVizMode+1)%5;
  document.getElementById('kvModeBtn').textContent = kvVizLabels[kvVizMode];
}

function kvToggleArrows() {
  kvShowArrows = !kvShowArrows;
  const btn = document.getElementById('kvArrowBtn');
  btn.textContent      = kvShowArrows ? 'ARROWS: ON'  : 'ARROWS: OFF';
  btn.style.color      = kvShowArrows ? '#ffffff'      : '#4ade80';
  btn.style.background = kvShowArrows ? '#166534'      : '';
}

function kvToggleModel() {
  kvCollModel = kvCollModel==='bgk' ? 'rlbm' : kvCollModel==='rlbm' ? 'clbm' : 'bgk';
  kvUpdateModelUI();
  kvInitLBM();
}

function kvUpdateModelUI() {
  const btn    = document.getElementById('kvModelBtn');
  const hint   = document.getElementById('kvHint');
  const slider = document.getElementById('kvTauSlider');
  const labels = {bgk:'MODEL: BGK', rlbm:'MODEL: RLBM', clbm:'MODEL: CLBM'};
  const colors = {bgk:'var(--accent2)', rlbm:'#a78bfa', clbm:'#34d399'};
  const hints  = {
    bgk:  '‚Üë <strong>BGK</strong>: Re 80‚Äì200 gives clear periodic shedding. Push œÑ lower for higher Re.',
    rlbm: '‚Üë <strong>RLBM</strong>: stable to œÑ = 0.501 ‚Äî push Re > 500 and watch the wake become chaotic.',
    clbm: '‚Üë <strong>Cumulant LBM</strong>: best accuracy at all Re. Galilean invariant, artefact-free.'
  };
  if (btn)    { btn.textContent=labels[kvCollModel]; btn.style.borderColor=colors[kvCollModel]; btn.style.color=colors[kvCollModel]; }
  if (hint)   hint.innerHTML = hints[kvCollModel];
  if (slider) slider.min = kvCollModel==='bgk' ? '0.52' : '0.501';
}

function kvUpdateTau(v) {
  kvTau = parseFloat(v);
  document.getElementById('kvTauVal').textContent = 'œÑ = '+kvTau.toFixed(3);
  const nu=(1/3)*(kvTau-0.5);
  document.getElementById('kvReVal').textContent = ((kvU*2*KCR)/nu).toFixed(0);
}
function kvUpdateU(v) {
  kvU = parseFloat(v);
  document.getElementById('kvUVal').textContent = 'u = '+kvU.toFixed(3);
  const nu=(1/3)*(kvTau-0.5);
  document.getElementById('kvReVal').textContent = ((kvU*2*KCR)/nu).toFixed(0);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SEMI-LAGRANGIAN LBM VISUALISATION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

let slbmInitDone  = false;
let slbmRAF       = null;
let slbmRunning   = true;
let slbmLastTs    = null;
let slbmSpeed     = 1.0;
let slbmStepIdx   = 0;       // 0..5 which animation step
let slbmStepTimer = 0;       // seconds elapsed in current step

// Step durations (seconds)
const SLBM_DUR = [3.4, 2.8, 2.4, 2.0, 2.2, 4.8, 2.6];

// ‚îÄ‚îÄ 5 Gauss-Lobatto-Chebyshev points on [-1,+1] ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Œæ_k = -cos(k¬∑œÄ/4), k=0..4
const GL5 = [-1, -Math.cos(Math.PI/4), 0, Math.cos(Math.PI/4), 1];

// ‚îÄ‚îÄ Unstructured-looking quad mesh (canvas coords baked in) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// We define a small patch of quads that look irregular but are
// topologically structured. Canvas: 580√ó520, content area centred.

function slbmMakeQuad(cx, cy, w, h, skewX, skewY) {
  // Returns 4 corners [TL,TR,BR,BL] with slight skew for organic look
  return [
    [cx - w/2 + skewX*0.3, cy - h/2 + skewY*0.2],
    [cx + w/2 + skewX*0.1, cy - h/2 - skewY*0.1],
    [cx + w/2 - skewX*0.2, cy + h/2 + skewY*0.3],
    [cx - w/2 - skewX*0.15,cy + h/2 - skewY*0.15]
  ];
}

// Unstructured quad mesh.
// HERO (index 4) = mid-centre cell ‚Äî departure point lies here.
// ARRIVAL_CELL (index 5) = mid-right cell ‚Äî arrival is an interior GL node there.
// Streaming crosses the shared edge between cells 4 and 5.
const SLBM_QUADS = [
  // top-left: tall narrow cell
  { verts: [[38,55],[155,42],[168,210],[44,228]]  },
  // top-centre: wide flat cell
  { verts: [[155,42],[310,52],[318,178],[168,210]] },
  // top-right: small squarish cell
  { verts: [[310,52],[455,38],[462,172],[318,178]] },
  // mid-left: large chunky cell
  { verts: [[44,228],[168,210],[178,355],[36,372]] },
  // mid-centre: HERO ‚Äî contains DEPART in interior
  { verts: [[168,210],[318,178],[338,320],[178,355]] },
  // mid-right: ARRIVAL_CELL ‚Äî ARRIVAL is interior GL node (i=2,j=2)
  { verts: [[318,178],[462,172],[470,335],[338,320]] },
  // bot-left: wide squat cell
  { verts: [[36,372],[178,355],[185,468],[30,472]] },
  // bot-centre: irregular parallelogram-ish
  { verts: [[178,355],[338,320],[348,460],[185,468]] },
  // bot-right: small compact cell
  { verts: [[338,320],[470,335],[475,458],[348,460]] }
];
const HERO         = 4;  // departure cell
const ARRIVAL_CELL = 5;  // arrival cell (mid-right)

// ‚îÄ‚îÄ Map reference coords [‚àí1,+1]¬≤ to any quad ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function bilinear(verts, xi, eta) {
  const [tl,tr,br,bl] = verts;
  const s = (xi  + 1) / 2;
  const t = (eta + 1) / 2;
  return [
    tl[0]*(1-s)*(1-t) + tr[0]*s*(1-t) + br[0]*s*t + bl[0]*(1-s)*t,
    tl[1]*(1-s)*(1-t) + tr[1]*s*(1-t) + br[1]*s*t + bl[1]*(1-s)*t
  ];
}

// Find reference coords of a world point inside a quad (Newton iteration)
function findRefCoords(verts, px, py) {
  let xi = 0, eta = 0;
  for (let iter=0; iter<60; iter++) {
    const [x,y] = bilinear(verts, xi, eta);
    const dx = px - x, dy = py - y;
    if (Math.sqrt(dx*dx+dy*dy) < 0.001) break;
    const dxi  = bilinear(verts, xi+0.001, eta);
    const deta = bilinear(verts, xi, eta+0.001);
    const J00 = (dxi[0]-x)/0.001,  J10 = (dxi[1]-y)/0.001;
    const J01 = (deta[0]-x)/0.001, J11 = (deta[1]-y)/0.001;
    const det = J00*J11 - J01*J10;
    if (Math.abs(det) < 1e-8) break;
    xi  += ( J11*dx - J01*dy) / det;
    eta += (-J10*dx + J00*dy) / det;
    xi  = Math.max(-1.5, Math.min(1.5, xi));
    eta = Math.max(-1.5, Math.min(1.5, eta));
  }
  return [xi, eta];
}

// e_1 = (1,0): exactly horizontal, length matches stencil ARM=118px
const E1_CANVAS = [118, 0];

// ‚îÄ‚îÄ ARRIVAL: interior GL node (i=2, j=2) of ARRIVAL_CELL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// This is the centre node of the right cell ‚Äî clearly not on any edge.
const heroVerts        = SLBM_QUADS[HERO].verts;
const arrivalCellVerts = SLBM_QUADS[ARRIVAL_CELL].verts;

const GL_NODES_ARRIVAL = (() => {
  const nodes = [];
  for (let j=0; j<5; j++)
    for (let i=0; i<5; i++) {
      const [cx,cy] = bilinear(arrivalCellVerts, GL5[i], GL5[j]);
      nodes.push({xi:GL5[i], eta:GL5[j], cx, cy, i, j});
    }
  return nodes;
})();

// Pick the (i=2, j=2) node of the arrival cell
const ARRIVAL_NODE = GL_NODES_ARRIVAL.find(n => n.i===2 && n.j===2);
const ARRIVAL = [Math.round(ARRIVAL_NODE.cx), Math.round(ARRIVAL_NODE.cy)];

// DEPART = ARRIVAL ‚àí e1¬∑Œît ‚Äî lies inside HERO cell
const DEPART = [ARRIVAL[0] - E1_CANVAS[0], ARRIVAL[1] - E1_CANVAS[1]];

// Reference coords of DEPART in hero cell (xi‚âà0.38, eta‚âà-0.11)
const [DEPART_XI, DEPART_ETA] = findRefCoords(heroVerts, DEPART[0], DEPART[1]);

// ‚îÄ‚îÄ 5√ó5 GL nodes in canvas coords on HERO cell ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function glNodes(verts) {
  const nodes = [];
  for (let j=0; j<5; j++)
    for (let i=0; i<5; i++) {
      const [cx,cy] = bilinear(verts, GL5[i], GL5[j]);
      nodes.push({xi:GL5[i], eta:GL5[j], cx, cy, i, j});
    }
  return nodes;
}
const GL_NODES = glNodes(heroVerts);

// ‚îÄ‚îÄ f values at GL nodes of HERO cell (smooth bump field) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function bumpF(xi, eta) {
  const g1 = Math.exp(-((xi-0.3)**2 + (eta+0.4)**2)/0.5);
  const g2 = Math.exp(-((xi+0.5)**2 + (eta-0.2)**2)/0.8) * 0.6;
  return 0.05 + 0.12*(g1 + g2);
}
for (const n of GL_NODES) n.f = bumpF(n.xi, n.eta);

// Interpolated value at departure point
function lagrange1D(xs, ys, x) {
  let val = 0;
  for (let i=0; i<xs.length; i++) {
    let L = ys[i];
    for (let j=0; j<xs.length; j++) {
      if (j!==i) L *= (x-xs[j])/(xs[i]-xs[j]);
    }
    val += L;
  }
  return val;
}
function interpolateAtDepart(xi, eta) {
  // 2D tensor product Lagrange interpolation
  // First interpolate along each row of xi for the 5 eta values
  const rowVals = [];
  for (let j=0; j<5; j++) {
    const fRow = GL5.map((xv,i) => GL_NODES[j*5+i].f);
    rowVals.push(lagrange1D(GL5, fRow, xi));
  }
  // Then interpolate in eta
  return lagrange1D(GL5, rowVals, eta);
}
const F_DEPART = interpolateAtDepart(DEPART_XI, DEPART_ETA);

// ‚îÄ‚îÄ Color helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function slbmJet(t) {
  t = Math.max(0, Math.min(1, t));
  let r,g,b;
  if      (t < 0.25) { r=0;          g=t*4;          b=1; }
  else if (t < 0.5)  { r=0;          g=1;            b=1-(t-0.25)*4; }
  else if (t < 0.75) { r=(t-0.5)*4; g=1;            b=0; }
  else               { r=1;          g=1-(t-0.75)*4; b=0; }
  return `rgb(${(r*255)|0},${(g*255)|0},${(b*255)|0})`;
}

const F_MIN = 0.03, F_MAX = 0.22;
function fToT(f) { return Math.max(0,Math.min(1,(f-F_MIN)/(F_MAX-F_MIN))); }

// ‚îÄ‚îÄ Draw a quad outline ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawQuad(ctx, verts, fill, stroke, lw, alpha) {
  ctx.save();
  ctx.globalAlpha = alpha ?? 1;
  ctx.beginPath();
  ctx.moveTo(verts[0][0], verts[0][1]);
  for (let i=1;i<verts.length;i++) ctx.lineTo(verts[i][0],verts[i][1]);
  ctx.closePath();
  if (fill)   { ctx.fillStyle = fill;   ctx.fill(); }
  if (stroke) { ctx.strokeStyle = stroke; ctx.lineWidth = lw??1; ctx.stroke(); }
  ctx.restore();
}

// ‚îÄ‚îÄ Step descriptions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const SLBM_STEPS = [
  {
    title: 'STEP 0 ¬∑ D2Q9 STENCIL',
    desc:  'At every node the Semi-Lagrangian LBM carries 9 distribution functions ‚Äî one per D2Q9 velocity direction. The stencil shows all 9 directions e‚ÇÄ..e‚Çà with their lattice weights. We will follow direction e‚ÇÅ = (1,0) through the full algorithm.',
    math:  'w_0=\\tfrac{4}{9},\\quad w_{1\\text{-}4}=\\tfrac{1}{9},\\quad w_{5\\text{-}8}=\\tfrac{1}{36}'
  },
  {
    title: 'STEP 1 ¬∑ UNSTRUCTURED MESH',
    desc:  'An unstructured quad mesh covers the domain. Each node stores 9 distribution functions fq (D2Q9). The highlighted node xA is our arrival node ‚Äî we want to find f‚ÇÅ(xA) after streaming.',
    math:  '\\mathbf{e}_1 = (1,\\,0)'
  },
  {
    title: 'STEP 2 ¬∑ TRACE CHARACTERISTIC',
    desc:  'We trace the characteristic of direction e‚ÇÅ backwards by one time step Œît. The departure point xD = xA ‚àí e‚ÇÅ¬∑Œît lies inside a neighbouring cell. This replaces the standard "pull from neighbour node" step.',
    math:  '\\mathbf{x}_D = \\mathbf{x}_A - \\mathbf{e}_1\\,\\Delta t'
  },
  {
    title: 'STEP 3 ¬∑ ZOOM INTO CELL',
    desc:  'We zoom into the cell containing xD. The cell is mapped to the reference square [‚àí1,+1]¬≤ via a bilinear transformation. The departure point gets reference coordinates (ŒæD, Œ∑D).',
    math:  '\\mathcal{F}:\\,[-1,+1]^2 \\to \\Omega_{\\mathrm{cell}}'
  },
  {
    title: 'STEP 4 ¬∑ GAUSS‚ÄìLOBATTO NODES',
    desc:  'On the reference cell, 5√ó5 = 25 Gauss‚ÄìLobatto‚ÄìChebyshev support nodes are placed. They cluster near the cell boundaries, minimising interpolation error. f‚ÇÅ is known at all 25 nodes.',
    math:  '\\xi_k = -\\cos\\!\\left(\\dfrac{k\\pi}{4}\\right),\\quad k=0,\\ldots,4'
  },
  {
    title: 'STEP 5 ¬∑ LAGRANGE INTERPOLATION',
    desc:  'All 25 GL nodes contribute to f*(xD). Ray thickness shows the Lagrange weight |L·µ¢(ŒæD)¬∑L‚±º(Œ∑D)| of each node ‚Äî nodes near the departure point (in reference space) carry more weight. The interpolated value accumulates at xD.',
    math:  'f^*(\\mathbf{x}_D)=\\sum_{ij}f_{ij}L_i(\\xi_D)L_j(\\eta_D)\\approx' + F_DEPART.toFixed(4)
  },
  {
    title: 'STEP 6 ¬∑ STREAM TO ARRIVAL',
    desc:  'The interpolated value f* = f‚ÇÅ(xD) is assigned to the arrival node: f‚ÇÅ(xA) ‚Üê f*. This completes the semi-Lagrangian streaming step. BGK collision then redistributes all fq at xA towards equilibrium.',
    math:  'f_i(\\mathbf{x}_A) \\leftarrow f_i^*(\\mathbf{x}_D) \\leftarrow f_i^{\\mathrm{eq}} - \\tfrac{f_i-f_i^{\\mathrm{eq}}}{\\tau}'
  }
];

// ‚îÄ‚îÄ Canvas resize: keep buffer in sync with CSS display size ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const SLBM_BASE_W = 580, SLBM_BASE_H = 520;  // design-time reference size

function slbmResizeCanvas() {
  const canvas = document.getElementById('slbmCanvas');
  if (!canvas) return;
  const dpr = window.devicePixelRatio || 1;
  const cssW = canvas.clientWidth;
  if (!cssW) return;
  const cssH = Math.round(cssW * SLBM_BASE_H / SLBM_BASE_W);
  canvas.width  = Math.round(cssW * dpr);
  canvas.height = Math.round(cssH * dpr);
  canvas.style.height = cssH + 'px';
}

(function() {
  let rafPending = false;
  const obs = new ResizeObserver(() => {
    // Defer to rAF so the resize runs outside the ResizeObserver callback,
    // preventing the "loop completed with undelivered notifications" error.
    if (!rafPending) {
      rafPending = true;
      requestAnimationFrame(() => { rafPending = false; slbmResizeCanvas(); });
    }
  });
  const waitCanvas = setInterval(() => {
    const c = document.getElementById('slbmCanvas');
    if (c) { obs.observe(c); slbmResizeCanvas(); clearInterval(waitCanvas); }
  }, 100);
})();

// ‚îÄ‚îÄ Main render ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function slbmRender(dt) {
  const canvas = document.getElementById('slbmCanvas');
  if (!canvas || !canvas.width) return;
  const ctx = canvas.getContext('2d');
  // Clear full pixel buffer
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  // Scale all drawing from design coords (580√ó520) to actual pixel buffer
  ctx.save();
  ctx.scale(canvas.width / SLBM_BASE_W, canvas.height / SLBM_BASE_H);
  // From here all coords are in design space: CW=580, CH=520
  const CW = SLBM_BASE_W, CH = SLBM_BASE_H;

  // Background fill in design coords
  ctx.fillStyle = '#070b12';
  ctx.fillRect(0, 0, CW, CH);

  slbmStepTimer += dt * slbmSpeed;
  const dur = SLBM_DUR[slbmStepIdx];
  if (slbmStepTimer >= dur) {
    slbmStepTimer -= dur;
    slbmStepIdx = (slbmStepIdx + 1) % 7;
    slbmUpdateUI();
  }
  const p = Math.min(slbmStepTimer / dur, 1);  // 0‚Üí1 within step
  const ep = 0.5 - 0.5*Math.cos(p*Math.PI);    // ease in-out

  const s = slbmStepIdx;

  // ‚îÄ‚îÄ Step 0: Full D2Q9 stencil at arrival node ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if (s === 0) {
    // Draw the unstructured mesh faded in background
    for (let qi=0; qi<SLBM_QUADS.length; qi++) {
      const q = SLBM_QUADS[qi];
      const isHero = qi === HERO;
      const isArrCell = qi === ARRIVAL_CELL;
      drawQuad(ctx, q.verts,
        isArrCell ? 'rgba(180,80,0,0.12)' : isHero ? 'rgba(0,80,160,0.12)' : 'rgba(15,40,80,0.10)',
        isArrCell ? 'rgba(251,146,60,0.55)': isHero ? 'rgba(0,160,230,0.45)': 'rgba(25,65,115,0.38)',
        (isHero||isArrCell) ? 1.2 : 0.6, 1);
    }
    // Draw all mesh nodes dimly
    const allNodes0 = new Map();
    for (const q of SLBM_QUADS)
      for (const v of q.verts) allNodes0.set(v[0].toFixed(0)+','+v[1].toFixed(0), v);
    for (const [,v] of allNodes0) {
      ctx.beginPath(); ctx.arc(v[0], v[1], 3, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(50,110,180,0.55)'; ctx.fill();
    }

    // D2Q9 stencil centred on ARRIVAL
    const AX = ARRIVAL[0], AY = ARRIVAL[1];
    const ARM = 118;  // arm length in px for stencil display

    // D2Q9: [ex, ey, weight_label, colour]
    // ex,ey in lattice coords (y up), we flip ey for canvas
    const D2Q9 = [
      [0,  0,  '4/9',  '#60a5fa', true],   // rest
      [1,  0,  '1/9',  '#34d399', false],
      [-1, 0,  '1/9',  '#34d399', false],
      [0,  1,  '1/9',  '#34d399', false],
      [0, -1,  '1/9',  '#34d399', false],
      [1,  1,  '1/36', '#f59e0b', false],
      [-1, 1,  '1/36', '#f59e0b', false],
      [1, -1,  '1/36', '#f59e0b', false],
      [-1,-1,  '1/36', '#f59e0b', false],
    ];

    // Fade in during first 40% of step, then full, then fade non-e1 out in last 30%
    const FADE_OUT_START = 0.70;
    const otherFade = p < FADE_OUT_START ? 1.0
                    : 1.0 - (p - FADE_OUT_START) / (1.0 - FADE_OUT_START);
    const stencilAlpha = Math.min(ep * 2.5, 1);

    // e1 highlight pulse (only while other arrows still visible)
    const e1pulse = 0.5 + 0.5*Math.sin(slbmStepTimer * 3.5);

    for (let di=0; di<D2Q9.length; di++) {
      const [dex, dey, wlabel, col, isRest] = D2Q9[di];
      const isE1 = dex===1 && dey===0;
      // non-e1 elements fade out; e1 stays at full alpha throughout
      const elemAlpha = isE1 ? stencilAlpha : stencilAlpha * otherFade;
      if (elemAlpha < 0.005) continue;

      if (isRest) {
        ctx.save(); ctx.globalAlpha = elemAlpha;
        ctx.beginPath(); ctx.arc(AX, AY, 14, 0, Math.PI*2);
        ctx.fillStyle = col; ctx.fill();
        ctx.globalAlpha = elemAlpha * 0.3;
        ctx.beginPath(); ctx.arc(AX, AY, 22, 0, Math.PI*2);
        ctx.fillStyle = col; ctx.fill();
        ctx.globalAlpha = elemAlpha;
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.font = '10px Space Mono, monospace';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(wlabel, AX, AY);
        ctx.restore();
        continue;
      }

      const tipX = AX + dex * ARM;
      const tipY = AY - dey * ARM;  // canvas y flipped
      const angle = Math.atan2(-dey, dex);

      ctx.save(); ctx.globalAlpha = elemAlpha;

      // Shaft glow for e1
      if (isE1) {
        ctx.beginPath(); ctx.moveTo(AX, AY); ctx.lineTo(tipX, tipY);
        ctx.strokeStyle = 'rgba(249,115,22,0.25)'; ctx.lineWidth = 12; ctx.stroke();
      }

      // Shaft
      const headLen = 18;
      const shaftEndX = tipX - Math.cos(angle)*headLen;
      const shaftEndY = tipY - Math.sin(angle)*headLen;
      ctx.beginPath(); ctx.moveTo(AX, AY); ctx.lineTo(shaftEndX, shaftEndY);
      ctx.strokeStyle = isE1 ? '#f97316' : col;
      ctx.lineWidth = isE1 ? 3 : 2;
      ctx.lineCap = 'round'; ctx.stroke();

      // Arrowhead
      const hw = isE1 ? 8 : 6;
      ctx.fillStyle = isE1 ? '#f97316' : col;
      ctx.beginPath();
      ctx.moveTo(tipX, tipY);
      ctx.lineTo(shaftEndX - Math.sin(angle)*hw, shaftEndY + Math.cos(angle)*hw);
      ctx.lineTo(shaftEndX + Math.sin(angle)*hw, shaftEndY - Math.cos(angle)*hw);
      ctx.closePath(); ctx.fill();

      // Weight label at tip (fades with non-e1, or for e1 also fades at end)
      const labAlpha = isE1 ? otherFade : 1.0;
      ctx.globalAlpha = elemAlpha * labAlpha;
      const labDist = ARM + 18;
      const lx = AX + dex*labDist, ly = AY - dey*labDist;
      ctx.fillStyle = isE1 ? '#f97316' : col;
      ctx.font = (isE1 ? 'bold ' : '') + '11px Space Mono, monospace';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(wlabel, lx, ly);

      // Direction label
      ctx.globalAlpha = elemAlpha * labAlpha;
      const dnames = ['','e‚ÇÅ','e‚ÇÉ','e‚ÇÇ','e‚ÇÑ','e‚ÇÖ','e‚ÇÜ','e‚Çá','e‚Çà'];
      const ld = ARM*0.52;
      const lx2 = AX + dex*ld, ly2 = AY - dey*ld;
      ctx.fillStyle = isE1 ? 'rgba(249,115,22,0.9)' : 'rgba(255,255,255,0.45)';
      ctx.font = '10px Space Mono, monospace';
      ctx.fillText(dnames[di], lx2, ly2 - 10);

      ctx.restore();
    }

    // Arrival node on top
    ctx.beginPath(); ctx.arc(AX, AY, 9, 0, Math.PI*2);
    ctx.fillStyle = '#00d4ff'; ctx.fill();
    ctx.strokeStyle = 'rgba(0,212,255,0.45)'; ctx.lineWidth = 3; ctx.stroke();
    ctx.fillStyle = '#00d4ff';
    ctx.font = 'bold 13px Space Mono, monospace';
    ctx.textAlign = 'left'; ctx.textBaseline = 'bottom';
    ctx.fillText('xA (interior GL node)', AX+14, AY-6);

    // Legend fades out together with other arrows
    ctx.save(); ctx.globalAlpha = Math.min(ep*3, 1) * otherFade;
    const lx = 18, ly = CH - 110;
    ctx.fillStyle = '#60a5fa'; ctx.beginPath(); ctx.arc(lx+6,ly,6,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = 'rgba(200,220,255,0.7)'; ctx.font='10px Space Mono,monospace';
    ctx.textAlign='left'; ctx.textBaseline='middle';
    ctx.fillText('w=4/9  rest', lx+16, ly);
    ctx.fillStyle='#34d399'; ctx.beginPath(); ctx.arc(lx+6,ly+20,5,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='rgba(200,220,255,0.7)'; ctx.fillText('w=1/9  cardinal', lx+16, ly+20);
    ctx.fillStyle='#f59e0b'; ctx.beginPath(); ctx.arc(lx+6,ly+40,5,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='rgba(200,220,255,0.7)'; ctx.fillText('w=1/36 diagonal', lx+16, ly+40);
    ctx.fillStyle='#f97316'; ctx.fillText('‚Üí e‚ÇÅ selected', lx+16, ly+62);
    ctx.restore();
  }

  // ‚îÄ‚îÄ Steps 1 & 2: draw full mesh ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if ((s >= 1 && s <= 2) || s === 6) {
    const meshAlpha = s === 5 ? 1 : 1;
    for (let qi=0; qi<SLBM_QUADS.length; qi++) {
      const q = SLBM_QUADS[qi];
      const isHero = qi === HERO;
      const isArrC = qi === ARRIVAL_CELL;
      const fill   = isArrC ? 'rgba(180,80,0,0.18)' : isHero ? 'rgba(0,100,180,0.18)' : 'rgba(20,50,90,0.12)';
      const stroke = isArrC ? 'rgba(251,146,60,0.8)' : isHero ? 'rgba(0,180,255,0.7)'  : 'rgba(30,80,130,0.55)';
      drawQuad(ctx, q.verts, fill, stroke, (isHero||isArrC)?1.5:0.8, meshAlpha);
    }

    // Draw mesh nodes
    const allNodes = new Map();
    for (const q of SLBM_QUADS)
      for (const v of q.verts) {
        const k = v[0].toFixed(0)+','+v[1].toFixed(0);
        allNodes.set(k, v);
      }
    for (const [,v] of allNodes) {
      ctx.beginPath(); ctx.arc(v[0], v[1], 4, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(60,130,200,0.7)'; ctx.fill();
    }

    // Draw ARRIVAL node explicitly (it's an interior GL node of ARRIVAL_CELL)
    ctx.beginPath(); ctx.arc(ARRIVAL[0], ARRIVAL[1], 7, 0, Math.PI*2);
    ctx.fillStyle = '#fb923c'; ctx.fill();
    ctx.strokeStyle = 'rgba(251,146,60,0.45)'; ctx.lineWidth = 2; ctx.stroke();
    ctx.fillStyle = '#fb923c';
    ctx.font = 'bold 13px Space Mono, monospace';
    ctx.textAlign = 'left'; ctx.textBaseline = 'bottom';
    ctx.fillText('xA', ARRIVAL[0]+10, ARRIVAL[1]-4);

    // GL support nodes always visible on hero cell ‚Äî faint green dots
    ctx.save(); ctx.globalAlpha = 0.28;
    for (const n of GL_NODES) {
      ctx.beginPath(); ctx.arc(n.cx, n.cy, 3, 0, Math.PI*2);
      ctx.fillStyle = '#34d399'; ctx.fill();
    }
    ctx.restore();
    // GL nodes of arrival cell ‚Äî faint orange dots
    ctx.save(); ctx.globalAlpha = 0.28;
    for (const n of GL_NODES_ARRIVAL) {
      const isArrNode = n.i===2 && n.j===2;
      ctx.beginPath(); ctx.arc(n.cx, n.cy, isArrNode ? 5 : 3, 0, Math.PI*2);
      ctx.fillStyle = isArrNode ? '#fb923c' : 'rgba(251,146,60,0.8)'; ctx.fill();
    }
    ctx.restore();

    // Step 1: e1 arrow fully visible from frame 0 (carried over from step 0)
    //         mesh fades in behind it with ep
    if (s === 1) {
      const tipX = ARRIVAL[0] + E1_CANVAS[0];
      const tipY = ARRIVAL[1] + E1_CANVAS[1];
      const ang  = Math.atan2(E1_CANVAS[1], E1_CANVAS[0]);
      const headLen = 18, hw = 8;
      const shaftEndX = tipX - Math.cos(ang)*headLen;
      const shaftEndY = tipY - Math.sin(ang)*headLen;
      ctx.save(); ctx.globalAlpha = 1;  // always fully visible ‚Äî no ep fade-in
      // Glow
      ctx.beginPath(); ctx.moveTo(ARRIVAL[0], ARRIVAL[1]); ctx.lineTo(tipX, tipY);
      ctx.strokeStyle = 'rgba(249,115,22,0.25)'; ctx.lineWidth = 12; ctx.stroke();
      // Shaft
      ctx.beginPath(); ctx.moveTo(ARRIVAL[0], ARRIVAL[1]); ctx.lineTo(shaftEndX, shaftEndY);
      ctx.strokeStyle = '#f97316'; ctx.lineWidth = 3; ctx.lineCap = 'round'; ctx.stroke();
      // Arrowhead
      ctx.fillStyle = '#f97316';
      ctx.beginPath();
      ctx.moveTo(tipX, tipY);
      ctx.lineTo(shaftEndX - Math.sin(ang)*hw, shaftEndY + Math.cos(ang)*hw);
      ctx.lineTo(shaftEndX + Math.sin(ang)*hw, shaftEndY - Math.cos(ang)*hw);
      ctx.closePath(); ctx.fill();
      // Label fades in with ep
      ctx.globalAlpha = ep;
      ctx.fillStyle = '#f97316';
      ctx.font = 'bold 12px Space Mono, monospace';
      ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
      ctx.fillText('e‚ÇÅ = (1, 0)', tipX + 30, tipY - 8);
      ctx.restore();
    }

    // Step 2: animate characteristic backwards, show departure point
    if (s === 2) {
      const trackX = ARRIVAL[0] - E1_CANVAS[0]*ep;
      const trackY = ARRIVAL[1] - E1_CANVAS[1]*ep;
      // Animated line
      ctx.save();
      ctx.strokeStyle = '#f97316'; ctx.lineWidth = 2.5;
      ctx.setLineDash([8,5]);
      ctx.beginPath(); ctx.moveTo(ARRIVAL[0], ARRIVAL[1]);
      ctx.lineTo(trackX, trackY); ctx.stroke();
      ctx.setLineDash([]);
      // Moving departure dot
      const dotR = 6 + 2*Math.sin(p*Math.PI*4);
      ctx.beginPath(); ctx.arc(trackX, trackY, dotR, 0, Math.PI*2);
      ctx.fillStyle = '#a78bfa'; ctx.fill();
      // Glow
      ctx.globalAlpha = 0.25;
      ctx.beginPath(); ctx.arc(trackX, trackY, dotR+8, 0, Math.PI*2);
      ctx.fillStyle = '#a78bfa'; ctx.fill();
      ctx.globalAlpha = 1;
      if (ep > 0.85) {
        ctx.fillStyle = '#a78bfa';
        ctx.font = 'bold 13px Space Mono, monospace';
        ctx.textAlign = 'right'; ctx.textBaseline = 'bottom';
        ctx.fillText('xD', trackX-8, trackY+4);
      }
      ctx.restore();
    }

    // Step 6: zoom out then stream value back
    if (s === 6) {
      const ZOOM_OUT_END = 0.28;  // first 28% of step: zoom out
      const hv6 = heroVerts;
      const hxs6 = hv6.map(v=>v[0]), hys6 = hv6.map(v=>v[1]);
      const hx06=Math.min(...hxs6), hx16=Math.max(...hxs6);
      const hy06=Math.min(...hys6), hy16=Math.max(...hys6);
      const hcx6=(hx06+hx16)/2, hcy6=(hy06+hy16)/2;
      const hspan6 = Math.max(hx16-hx06, hy16-hy06);
      const targetScale6 = Math.min(CW, CH) / (hspan6 * 1.35);

      if (ep < ZOOM_OUT_END) {
        // Zoom-out phase: interpolate scale from targetScale back to 1
        const zoomOutT = 1 - ep / ZOOM_OUT_END;  // 1‚Üí0
        const zoomOutEp = 0.5 - 0.5*Math.cos(zoomOutT * Math.PI); // ease
        const curScale6 = 1 + (targetScale6 - 1) * zoomOutEp;
        const endTx6 = CW/2 - hcx6 * targetScale6;
        const endTy6 = CH/2 - hcy6 * targetScale6;
        const ttx6 = endTx6 * zoomOutEp;
        const tty6 = endTy6 * zoomOutEp;
        function mapZ6(px,py) { return [ttx6+px*curScale6, tty6+py*curScale6]; }
        ctx.save();
        ctx.globalAlpha = Math.max(0.2, zoomOutEp);
        const zv6 = hv6.map(v=>mapZ6(v[0],v[1]));
        drawQuad(ctx, zv6, 'rgba(0,60,140,0.18)', 'rgba(0,180,255,0.7)', 1.5, 1);
        // departure point dot in zoomed view
        const [dpzx6,dpzy6] = mapZ6(DEPART[0],DEPART[1]);
        ctx.beginPath(); ctx.arc(dpzx6,dpzy6, 7,0,Math.PI*2);
        ctx.fillStyle='#a78bfa'; ctx.fill();
        // f* label
        ctx.fillStyle='#fbbf24';
        ctx.font='bold 11px Space Mono,monospace';
        ctx.textAlign='left'; ctx.textBaseline='middle';
        ctx.fillText('f*='+F_DEPART.toFixed(4), dpzx6+10, dpzy6);
        ctx.restore();
      } else {
        // Stream phase: f* travels from DEPART to ARRIVAL in world coords
        const streamFrac = (ep - ZOOM_OUT_END) / (1 - ZOOM_OUT_END);
        const streamEp = 0.5 - 0.5*Math.cos(streamFrac * Math.PI);
        const ttx = DEPART[0] + (ARRIVAL[0]-DEPART[0])*streamEp;
        const tty = DEPART[1] + (ARRIVAL[1]-DEPART[1])*streamEp;
        ctx.save();
        // Show both cells faintly in background
        ctx.save(); ctx.globalAlpha = 0.35;
        drawQuad(ctx, heroVerts, 'rgba(0,80,160,0.15)', 'rgba(0,180,255,0.5)', 1.2, 1);
        drawQuad(ctx, arrivalCellVerts, 'rgba(180,80,0,0.15)', 'rgba(251,146,60,0.5)', 1.2, 1);
        ctx.restore();
        // Departure source dot (faint purple ‚Äî was xD in hero cell)
        ctx.globalAlpha = 0.4;
        ctx.beginPath(); ctx.arc(DEPART[0],DEPART[1],6,0,Math.PI*2);
        ctx.fillStyle='#a78bfa'; ctx.fill();
        ctx.globalAlpha = 1;
        // Trail
        const grad = ctx.createLinearGradient(DEPART[0],DEPART[1],ttx,tty);
        grad.addColorStop(0, 'rgba(251,191,36,0)');
        grad.addColorStop(1, 'rgba(251,191,36,0.5)');
        ctx.strokeStyle = grad; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(DEPART[0],DEPART[1]); ctx.lineTo(ttx,tty); ctx.stroke();
        // Moving value dot
        const sz = 8 + 3*Math.sin(streamFrac*Math.PI*3);
        ctx.beginPath(); ctx.arc(ttx, tty, sz, 0, Math.PI*2);
        ctx.fillStyle = slbmJet(fToT(F_DEPART)); ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth = 1.5; ctx.stroke();
        ctx.fillStyle = '#fbbf24';
        ctx.font = 'bold 12px Space Mono, monospace';
        ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
        ctx.fillText('f* = ' + F_DEPART.toFixed(4), ttx, tty - 13);
        // Pulse arrival node at end
        if (streamFrac > 0.8) {
          const pulse = (streamFrac-0.8)/0.2;
          ctx.globalAlpha = pulse*0.4;
          ctx.beginPath(); ctx.arc(ARRIVAL[0],ARRIVAL[1], 7+pulse*16, 0, Math.PI*2);
          ctx.fillStyle = slbmJet(fToT(F_DEPART)); ctx.fill();
          ctx.globalAlpha = 1;
        }
        ctx.restore();
      }
    }
  }

  // ‚îÄ‚îÄ Steps 3‚Äì5: zoom into hero cell (with animated zoom in/out) ‚îÄ‚îÄ
  if (s >= 3 && s <= 5) {
    const hv = heroVerts;
    const hxs = hv.map(v=>v[0]), hys = hv.map(v=>v[1]);
    const hx0=Math.min(...hxs), hx1=Math.max(...hxs);
    const hy0=Math.min(...hys), hy1=Math.max(...hys);
    const hcx=(hx0+hx1)/2, hcy=(hy0+hy1)/2;
    const hspan = Math.max(hx1-hx0, hy1-hy0);
    // Target scale so cell fills canvas with padding
    const targetScale = Math.min(CW, CH) / (hspan * 1.35);

    // Zoom parameter: 0=full mesh view, 1=fully zoomed in
    // Step 3: zoom IN (0‚Üí1), Steps 4-5: stay zoomed (1), Step 6 will zoom out
    let zoomT;
    if (s === 3) {
      zoomT = ep;  // ease in during step 3
    } else {
      zoomT = 1;   // fully zoomed for steps 4-5
    }

    // Correct zoom interpolation:
    //   zoomT=0 ‚Üí identity (world coords unchanged: scale=1, tx=0, ty=0)
    //   zoomT=1 ‚Üí cell centre mapped to canvas centre at targetScale
    const curScale = 1 + (targetScale - 1) * zoomT;
    const endTx = CW/2 - hcx * targetScale;
    const endTy = CH/2 - hcy * targetScale;
    const tx = endTx * zoomT;   // at zoomT=0: tx=0 ‚Üí identity
    const ty = endTy * zoomT;   // at zoomT=0: ty=0 ‚Üí identity

    // Helper: map world coords to zoomed canvas coords
    function mapToZoom(px, py) {
      return [tx + px * curScale, ty + py * curScale];
    }

    // Draw full mesh fading out during zoom-in (step 3)
    if (s === 3) {
      ctx.save(); ctx.globalAlpha = 1 - ep * 0.85;
      for (let qi=0; qi<SLBM_QUADS.length; qi++) {
        const q = SLBM_QUADS[qi];
        const isAC = qi===ARRIVAL_CELL;
        drawQuad(ctx, q.verts,
          isAC?'rgba(180,80,0,0.22)':qi===HERO?'rgba(0,100,180,0.22)':'rgba(20,50,90,0.12)',
          isAC?'rgba(251,146,60,0.8)':qi===HERO?'rgba(0,180,255,0.8)':'rgba(30,80,130,0.5)',
          (qi===HERO||isAC)?1.8:0.8, 1);
      }
      const allNodesFade = new Map();
      for (const q of SLBM_QUADS)
        for (const v of q.verts) allNodesFade.set(v[0].toFixed(0)+','+v[1].toFixed(0), v);
      for (const [,v] of allNodesFade) {
        ctx.beginPath(); ctx.arc(v[0], v[1], 4, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(60,130,200,0.6)'; ctx.fill();
      }
      // ARRIVAL node visible during zoom-in
      ctx.globalAlpha = (1 - ep * 0.85) * 0.7;
      ctx.beginPath(); ctx.arc(ARRIVAL[0], ARRIVAL[1], 6, 0, Math.PI*2);
      ctx.fillStyle = '#fb923c'; ctx.fill();
      ctx.restore();
    }

    // Draw zoomed cell using ctx transform
    ctx.save();
    ctx.globalAlpha = s === 3 ? ep : 1;
    const zverts = hv.map(v => mapToZoom(v[0],v[1]));
    drawQuad(ctx, zverts, 'rgba(0,60,140,0.22)', 'rgba(0,180,255,0.9)', 2, 1);

    // Draw reference grid lines inside cell (light)
    ctx.strokeStyle = 'rgba(0,120,200,0.2)'; ctx.lineWidth = 0.5;
    for (let k=0; k<=8; k++) {
      const xi = -1 + k*0.25;
      const [ax,ay] = mapToZoom(...bilinear(hv, xi, -1));
      const [bx,by] = mapToZoom(...bilinear(hv, xi,  1));
      ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.stroke();
    }
    for (let k=0; k<=8; k++) {
      const et = -1 + k*0.25;
      const [ax,ay] = mapToZoom(...bilinear(hv,-1,et));
      const [bx,by] = mapToZoom(...bilinear(hv, 1,et));
      ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.stroke();
    }

    // Draw departure point in zoomed view
    const [dpzx, dpzy] = mapToZoom(DEPART[0], DEPART[1]);
    const dpAlpha = s === 2 ? ep : 1;
    ctx.globalAlpha = dpAlpha;
    const dpPulse = 6 + 2.5*Math.sin(slbmStepTimer*4);
    ctx.beginPath(); ctx.arc(dpzx, dpzy, dpPulse, 0, Math.PI*2);
    ctx.fillStyle = '#a78bfa'; ctx.fill();
    ctx.globalAlpha = dpAlpha * 0.3;
    ctx.beginPath(); ctx.arc(dpzx, dpzy, dpPulse+10, 0, Math.PI*2);
    ctx.fillStyle = '#a78bfa'; ctx.fill();
    ctx.globalAlpha = dpAlpha;
    // xD label: above the dot with a background pill ‚Äî readable even when GL nodes are dense
    {
      const lbl = 'xD  (ŒæD=' + DEPART_XI.toFixed(2) + ',  Œ∑D=' + DEPART_ETA.toFixed(2) + ')';
      ctx.save();
      ctx.font = 'bold 12px Space Mono, monospace';
      ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
      const tw = ctx.measureText(lbl).width;
      const lx = dpzx;
      const ly = dpzy - dpPulse - 14;  // above the pulsing circle
      const pad = 7;
      // Dark background pill
      ctx.globalAlpha = dpAlpha;
      ctx.fillStyle = 'rgba(12,18,32,0.88)';
      ctx.beginPath();
      if (ctx.roundRect) ctx.roundRect(lx - tw/2 - pad, ly - 15, tw + pad*2, 18, 4);
      else ctx.rect(lx - tw/2 - pad, ly - 15, tw + pad*2, 18);
      ctx.fill();
      // Text
      ctx.fillStyle = '#c4b5fd';
      ctx.fillText(lbl, lx, ly);
      ctx.restore();
    }

    // Step 3+: draw GL nodes ‚Äî faint in step 3, gaining colour/size in 4-5
    if (s >= 3) {
      for (let ni=0; ni<GL_NODES.length; ni++) {
        const n = GL_NODES[ni];
        const [nx,ny] = mapToZoom(n.cx, n.cy);
        const t = fToT(n.f);

        if (s === 3) {
          // Zoom-in step: just faint green dots, fade in with zoomT
          ctx.save();
          ctx.globalAlpha = 0.30 * zoomT;
          ctx.beginPath(); ctx.arc(nx, ny, 4, 0, Math.PI*2);
          ctx.fillStyle = '#34d399'; ctx.fill();
          ctx.restore();
        } else if (s === 4) {
          // GL labels step: full green, sized uniformly, glow halo
          ctx.save(); ctx.globalAlpha = 1;
          ctx.globalAlpha = 0.2;
          ctx.beginPath(); ctx.arc(nx,ny, 13, 0, Math.PI*2);
          ctx.fillStyle = '#34d399'; ctx.fill();
          ctx.globalAlpha = 1;
          ctx.beginPath(); ctx.arc(nx, ny, 5, 0, Math.PI*2);
          ctx.fillStyle = '#34d399'; ctx.fill();
          ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 0.8; ctx.stroke();
          // Axis labels
          if (n.j === 4) {
            const labels = ['Œæ‚ÇÄ=‚àí1','Œæ‚ÇÅ','Œæ‚ÇÇ=0','Œæ‚ÇÉ','Œæ‚ÇÑ=+1'];
            ctx.fillStyle = 'rgba(52,211,153,0.8)';
            ctx.font = '10px Space Mono, monospace';
            ctx.textAlign = 'center'; ctx.textBaseline = 'top';
            ctx.fillText(labels[n.i], nx, ny+8);
          }
          if (n.i === 4) {
            const labels = ['Œ∑‚ÇÄ=‚àí1','Œ∑‚ÇÅ','Œ∑‚ÇÇ=0','Œ∑‚ÇÉ','Œ∑‚ÇÑ=+1'];
            ctx.fillStyle = 'rgba(52,211,153,0.8)';
            ctx.font = '10px Space Mono, monospace';
            ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
            ctx.fillText(labels[n.j], nx+10, ny);
          }
          ctx.restore();
        } else if (s === 5) {
          // Interpolation step: jet coloured, size proportional to f
          const r = 5 + t*6;
          ctx.save();
          ctx.globalAlpha = 0.22;
          ctx.beginPath(); ctx.arc(nx,ny, r+8, 0, Math.PI*2);
          ctx.fillStyle = slbmJet(t); ctx.fill();
          ctx.globalAlpha = 1;
          ctx.beginPath(); ctx.arc(nx, ny, r, 0, Math.PI*2);
          ctx.fillStyle = slbmJet(t); ctx.fill();
          ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 0.8; ctx.stroke();
          // f value for corner nodes
          if ((n.i===0||n.i===2||n.i===4) && (n.j===0||n.j===2||n.j===4)) {
            ctx.fillStyle = 'rgba(255,255,255,0.85)';
            ctx.font = '9px Space Mono, monospace';
            ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
            ctx.fillText(n.f.toFixed(3), nx, ny-r-2);
          }
          ctx.restore();
        }
      }
    }

    // Step 5: animated Lagrange interpolation
    if (s === 5) {
      // Compute 1D Lagrange weights at departure ref coords
      function lagW1D(xs, x) {
        return xs.map((xi,i) => {
          let L = 1;
          for (let j=0;j<xs.length;j++) if(j!==i) L *= (x-xs[j])/(xi-xs[j]);
          return L;
        });
      }
      const Lxi  = lagW1D(GL5, DEPART_XI);
      const Leta = lagW1D(GL5, DEPART_ETA);
      // Weight of each GL node = |L_i(xi_D)| * |L_j(eta_D)|
      const nodeW = GL_NODES.map(n => Math.abs(Lxi[n.i]) * Math.abs(Leta[n.j]));
      const maxW  = Math.max(...nodeW);

      // Three animation phases
      const PH1_END = 0.42;  // rays fly from nodes to xD
      const PH2_END = 0.72;  // rays pulse with weight thickness
      const PH3_END = 1.00;  // f* accumulates at xD, surface reveals

      // ‚îÄ‚îÄ Background polynomial surface (always visible, fades in) ‚îÄ‚îÄ
      const surfAlpha = ep < PH2_END ? (ep/PH2_END)*0.10 : 0.10 + (ep-PH2_END)/(1-PH2_END)*0.18;
      ctx.save(); ctx.globalAlpha = surfAlpha;
      const res = 20;
      for (let jj=0; jj<res; jj++) {
        for (let ii=0; ii<res; ii++) {
          const xi0=-1+ii*(2/res), xi1=-1+(ii+1)*(2/res);
          const et0=-1+jj*(2/res), et1=-1+(jj+1)*(2/res);
          const fval = interpolateAtDepart((xi0+xi1)/2, (et0+et1)/2);
          const pv=[mapToZoom(...bilinear(hv,xi0,et0)),mapToZoom(...bilinear(hv,xi1,et0)),
                    mapToZoom(...bilinear(hv,xi1,et1)),mapToZoom(...bilinear(hv,xi0,et1))];
          ctx.beginPath(); ctx.moveTo(pv[0][0],pv[0][1]);
          for(let k=1;k<4;k++) ctx.lineTo(pv[k][0],pv[k][1]);
          ctx.closePath(); ctx.fillStyle=slbmJet(fToT(fval)); ctx.fill();
        }
      }
      ctx.restore();

      // ‚îÄ‚îÄ Phase 1+2: rays from GL nodes to departure point ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      if (ep < PH2_END) {
        const phT = ep < PH1_END ? ep/PH1_END : 1.0;   // 0‚Üí1 for ray travel
        const pulseT = ep < PH1_END ? 0 : (ep-PH1_END)/(PH2_END-PH1_END); // 0‚Üí1 pulse

        for (let ni=0; ni<GL_NODES.length; ni++) {
          const n = GL_NODES[ni];
          const [nx,ny] = mapToZoom(n.cx, n.cy);
          const w = nodeW[ni] / maxW;  // 0..1 normalised influence

          // Each node has a staggered delay based on distance to xD
          const distXi  = Math.abs(n.xi  - DEPART_XI);
          const distEta = Math.abs(n.eta - DEPART_ETA);
          const dist = Math.sqrt(distXi*distXi + distEta*distEta);
          const maxDist = Math.sqrt(4+4);
          const delay = (dist / maxDist) * 0.35;   // far nodes start later
          const localT = Math.max(0, Math.min(1, (phT - delay) / (1 - delay)));
          const rayEp = 0.5 - 0.5*Math.cos(localT*Math.PI);

          if (rayEp <= 0) continue;

          // Ray tip travels from node ‚Üí xD
          const rtx = nx + (dpzx - nx) * rayEp;
          const rty = ny + (dpzy - ny) * rayEp;

          // Line width proportional to Lagrange weight
          const baseWidth = 0.5 + w * 4.5;
          const pulseWidth = pulseT > 0
            ? baseWidth * (1 + 0.6*Math.sin(pulseT*Math.PI*2 + ni*0.3))
            : baseWidth;

          // Colour: interpolate between node jet colour and purple (xD colour)
          const nodeCol = slbmJet(fToT(n.f));

          ctx.save();
          ctx.globalAlpha = 0.15 + w * 0.7 * rayEp;
          // Gradient along ray: node colour ‚Üí purple
          const rg = ctx.createLinearGradient(nx,ny,rtx,rty);
          rg.addColorStop(0, nodeCol);
          rg.addColorStop(1, '#a78bfa');
          ctx.strokeStyle = rg;
          ctx.lineWidth = pulseWidth;
          ctx.lineCap = 'round';
          ctx.beginPath(); ctx.moveTo(nx,ny); ctx.lineTo(rtx,rty); ctx.stroke();

          // Small glowing dot at ray tip
          if (localT > 0.5) {
            ctx.globalAlpha = w * 0.6 * rayEp;
            ctx.beginPath(); ctx.arc(rtx,rty, 2+w*3, 0, Math.PI*2);
            ctx.fillStyle = '#a78bfa'; ctx.fill();
          }
          ctx.restore();
        }
      }

      // ‚îÄ‚îÄ Phase 3: accumulated f* builds up at xD ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      if (ep >= PH2_END) {
        const accT = (ep - PH2_END) / (PH3_END - PH2_END);  // 0‚Üí1
        const accEp = 0.5 - 0.5*Math.cos(accT*Math.PI);

        // Show all rays fully converged (static, weight-width)
        for (let ni=0; ni<GL_NODES.length; ni++) {
          const n = GL_NODES[ni];
          const [nx,ny] = mapToZoom(n.cx, n.cy);
          const w = nodeW[ni] / maxW;
          ctx.save();
          ctx.globalAlpha = 0.12 + w * 0.25;
          const rg = ctx.createLinearGradient(nx,ny,dpzx,dpzy);
          rg.addColorStop(0, slbmJet(fToT(n.f)));
          rg.addColorStop(1, '#a78bfa');
          ctx.strokeStyle = rg;
          ctx.lineWidth = 0.5 + w * 3.5;
          ctx.lineCap = 'round';
          ctx.beginPath(); ctx.moveTo(nx,ny); ctx.lineTo(dpzx,dpzy); ctx.stroke();
          ctx.restore();
        }

        // f* value disc growing at xD: colour transitions from purple to jet(F_DEPART)
        const discR = 6 + accEp * 16;
        // Interpolate colour: purple ‚Üí final f* colour
        const finalT = fToT(F_DEPART);
        // Parse jet colour at accEp blend
        ctx.save();
        ctx.globalAlpha = 0.35;
        ctx.beginPath(); ctx.arc(dpzx,dpzy, discR+14, 0, Math.PI*2);
        ctx.fillStyle = slbmJet(finalT); ctx.fill();
        ctx.globalAlpha = 1;
        ctx.beginPath(); ctx.arc(dpzx,dpzy, discR, 0, Math.PI*2);
        // disc transitions: purple at accEp=0, jet colour at accEp=1
        const mixR = Math.round(167 + (parseInt(slbmJet(finalT).slice(4),10) - 167)*accEp);
        ctx.fillStyle = slbmJet(finalT * accEp);
        ctx.fill();
        ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.stroke();

        // f* value label: above the disc with background pill ‚Äî always readable
        {
          const fDisp = (F_DEPART * accEp).toFixed(4);
          const lbl = 'f*(xD) = ' + fDisp;
          ctx.font = 'bold 12px Space Mono, monospace';
          ctx.textAlign = 'center'; ctx.textBaseline = 'top';
          const tw = ctx.measureText(lbl).width;
          const lx = dpzx;
          const ly = dpzy + discR + 26;  // below the disc, clear of the xD label above
          const pad = 7;
          // Background pill
          ctx.globalAlpha = accEp * 0.88;
          ctx.fillStyle = 'rgba(12,18,32,0.90)';
          ctx.beginPath();
          if (ctx.roundRect) ctx.roundRect(lx - tw/2 - pad, ly - 2, tw + pad*2, 18, 4);
          else ctx.rect(lx - tw/2 - pad, ly - 2, tw + pad*2, 18);
          ctx.fill();
          // Text
          ctx.globalAlpha = accEp;
          ctx.fillStyle = 'white';
          ctx.fillText(lbl, lx, ly);
        }
        ctx.restore();
      }

      // ‚îÄ‚îÄ Color bar ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const cbX = CW - 55, cbY = 60, cbH = 200;
      for (let k=0; k<cbH; k++) {
        ctx.fillStyle = slbmJet(1-k/cbH);
        ctx.fillRect(cbX, cbY+k, 16, 1);
      }
      ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 0.7;
      ctx.strokeRect(cbX, cbY, 16, cbH);
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      ctx.font = '9px Space Mono, monospace';
      ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
      ctx.fillText(F_MAX.toFixed(2), cbX+20, cbY);
      ctx.fillText(F_MIN.toFixed(2), cbX+20, cbY+cbH);
      ctx.save(); ctx.translate(cbX-8, cbY+cbH/2);
      ctx.rotate(-Math.PI/2);
      ctx.textAlign='center'; ctx.textBaseline='bottom';
      ctx.fillText('f‚ÇÅ', 0, 0);
      ctx.restore();
    }

    ctx.restore();
  }

  // ‚îÄ‚îÄ Step title overlay ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  ctx.fillStyle = 'rgba(0,180,255,0.06)';
  ctx.fillRect(0, CH-44, CW, 44);
  ctx.fillStyle = 'rgba(0,180,255,0.5)';
  ctx.font = '10px Space Mono, monospace';
  ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
  ctx.fillText(SLBM_STEPS[s].title, 14, CH-22);

  // Progress dots
  for (let k=0; k<7; k++) {
    ctx.beginPath(); ctx.arc(CW-126+k*16, CH-22, k===s?4:2.5, 0, Math.PI*2);
    ctx.fillStyle = k===s ? '#00d4ff' : 'rgba(0,180,255,0.3)';
    ctx.fill();
  }

  // Restore the scale transform applied at the top of slbmRender
  ctx.restore();
}

// ‚îÄ‚îÄ Update sidebar UI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function slbmUpdateUI() {
  const s = slbmStepIdx;
  const step = SLBM_STEPS[s];
  const titleEl = document.getElementById('slbmStepTitle');
  const descEl  = document.getElementById('slbmStepDesc');
  const mathEl  = document.getElementById('slbmMath');
  const labelEl = document.getElementById('slbmPhaseLabel');
  if (titleEl) titleEl.textContent = step.title;
  if (descEl)  descEl.textContent  = step.desc;
  if (mathEl) {
    if (typeof katex !== 'undefined') {
      try {
        katex.render(step.math, mathEl, {throwOnError: false, displayMode: true});
      } catch(e) { mathEl.textContent = step.math; }
    } else {
      mathEl.textContent = step.math;
    }
  }
  if (labelEl) labelEl.textContent = step.title;
  for (let k=0; k<7; k++) {
    const el = document.getElementById('slbmT'+k);
    if (el) el.classList.toggle('active-track', k===s);
  }
}

// ‚îÄ‚îÄ Loop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function slbmLoop(ts) {
  if (!slbmRunning) { slbmRAF = null; return; }
  const dt = slbmLastTs !== null ? Math.min((ts-slbmLastTs)/1000, 0.1) : 0;
  slbmLastTs = ts;
  slbmRender(dt);
  slbmRAF = requestAnimationFrame(slbmLoop);
}

function slbmStart() {
  if (slbmRAF) return;
  slbmLastTs = null;
  slbmRAF = requestAnimationFrame(slbmLoop);
}

function slbmToggle() {
  slbmRunning = !slbmRunning;
  const btn = document.getElementById('slbmPauseBtn');
  if (btn) btn.textContent = slbmRunning ? '‚ñ† PAUSE' : '‚ñ∂ PLAY';
  if (slbmRunning) slbmStart();
}

function slbmGoPhase(k) {
  // Jump to phase k, reset the phase timer, and pause so user can study it
  slbmStepIdx   = k;
  slbmStepTimer = 0;
  slbmUpdateUI();
  // Pause
  slbmRunning = false;
  const btn = document.getElementById('slbmPauseBtn');
  if (btn) btn.textContent = '‚ñ∂ PLAY';
  // Still render one frame so the canvas updates immediately
  const canvas = document.getElementById('slbmCanvas');
  if (canvas) slbmRender(0);
}

document.addEventListener('DOMContentLoaded', () => {
  const spd = document.getElementById('slbmSpeedSlider');
  if (spd) spd.addEventListener('input', e => { slbmSpeed = parseFloat(e.target.value); });
});

function slbmInitIfNeeded() {
  if (slbmInitDone) return;
  slbmInitDone = true;
  slbmUpdateUI();
  slbmStart();
}


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// D3Q27 INTERACTIVE 3D STENCIL  (D3Q15 / D3Q19 / D3Q27 selector)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
(function() {

// ‚îÄ‚îÄ Stencil definitions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// type: 0=centre, 1=face(|e|=1), 2=edge(|e|=‚àö2), 3=corner(|e|=‚àö3)
// node speed-squared for depth sort only (not physical weights)
const W = { 0: 0, 1: 1, 2: 2, 3: 3 }; // used only as type key

const STENCILS = {
  15: {
    label: 'D3Q15',
    types: [0, 1, 3],   // centre + 6 face + 8 corner  = 15
    desc:  'D3Q15 ‚Äî 1 centre + 6 face (¬±1,0,0) + 8 corner (¬±1,¬±1,¬±1) = 15 velocities.\nOmits edge directions (|e|=‚àö2). Lowest memory; less isotropic than D3Q19/27.'
  },
  19: {
    label: 'D3Q19',
    types: [0, 1, 2],   // centre + 6 face + 12 edge   = 19
    desc:  'D3Q19 ‚Äî 1 centre + 6 face (¬±1,0,0) + 12 edge (¬±1,¬±1,0) = 19 velocities.\nOmits corner directions (|e|=‚àö3). Good balance of accuracy and cost; most popular 3D choice.'
  },
  27: {
    label: 'D3Q27',
    types: [0, 1, 2, 3], // all 27
    desc:  'D3Q27 ‚Äî full 3√ó3√ó3 tensor product: 1 + 6 + 12 + 8 = 27 velocities.\nAll directions included. Best isotropy; used in Cumulant LBM and compressible extensions.'
  }
};

const TYPE_LABEL = ['centre','face','edge','corner'];
const TYPE_COLOR  = ['#00d4ff','#4ade80','#f97316','#a78bfa'];
const TYPE_DIM    = ['rgba(0,180,210,0.18)','rgba(74,222,128,0.18)','rgba(249,115,22,0.18)','rgba(167,139,250,0.18)'];

// Build all 27 nodes once
const NODES = [];
for (let dz=-1; dz<=1; dz++) for (let dy=-1; dy<=1; dy++) for (let dx=-1; dx<=1; dx++) {
  const n = Math.abs(dx)+Math.abs(dy)+Math.abs(dz);
  const type = n===0?0:(n===1?1:(n===2?2:3));
  NODES.push({dx,dy,dz,type,w:W[type]});
}

// State
let rotX=0.42, rotY=-0.55;
let dragging=false, lastMX=0, lastMY=0;
let hovered=null;
let activeStencil=27;

function inStencil(node) {
  return STENCILS[activeStencil].types.includes(node.type);
}

function project(x,y,z,cx,cy,scale) {
  const cosY=Math.cos(rotY),sinY=Math.sin(rotY),cosX=Math.cos(rotX),sinX=Math.sin(rotX);
  const rx=x*cosY-z*sinY, ry2=z*cosY+x*sinY;
  const ry=y*cosX-ry2*sinX, rz=ry2*cosX+y*sinX;
  return {sx:cx+rx*scale, sy:cy-ry*scale, depth:rz};
}

function drawD3Q27() {
  const canvas=document.getElementById('d3q27Canvas'); if(!canvas) return;
  const ctx=canvas.getContext('2d');
  const W2=canvas.width, H=canvas.height, cx=W2/2, cy=H/2, scale=W2*0.18;
  ctx.fillStyle='#070b12'; ctx.fillRect(0,0,W2,H);

  const projected=NODES.map((n,i)=>{
    const p=project(n.dx,n.dy,n.dz,cx,cy,scale);
    return {...n,...p,idx:i};
  }).sort((a,b)=>a.depth-b.depth);

  // Box outline
  ctx.strokeStyle='rgba(30,58,95,0.5)'; ctx.lineWidth=0.8;
  const corn=[[-1,-1,-1],[1,-1,-1],[1,1,-1],[-1,1,-1],[-1,-1,1],[1,-1,1],[1,1,1],[-1,1,1]];
  const edg=[[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
  const cp=corn.map(([x,y,z])=>project(x,y,z,cx,cy,scale));
  edg.forEach(([a,b])=>{ ctx.beginPath(); ctx.moveTo(cp[a].sx,cp[a].sy); ctx.lineTo(cp[b].sx,cp[b].sy); ctx.stroke(); });

  // Draw centre node first (behind everything)
  const cen=project(0,0,0,cx,cy,scale);
  ctx.beginPath(); ctx.arc(cen.sx,cen.sy,9,0,Math.PI*2);
  ctx.fillStyle='#00d4ff'; ctx.fill();
  ctx.strokeStyle='rgba(255,255,255,0.4)'; ctx.lineWidth=1.5; ctx.stroke();

  // Arrows: shaft + proper arrowhead, no dot at tip
  projected.forEach(n=>{
    if(n.dx===0&&n.dy===0&&n.dz===0) return;
    const active=inStencil(n);
    const col=active?TYPE_COLOR[n.type]:'rgba(40,55,75,0.45)';
    const ang=Math.atan2(n.sy-cen.sy,n.sx-cen.sx);
    const hl=active?10:6;       // arrowhead length
    const hw=active?0.38:0.28;  // arrowhead half-angle
    const lw=active?1.8:0.7;
    // Stop shaft just before the arrowhead base so it doesn't bleed through
    const tipX=n.sx, tipY=n.sy;
    const baseX=tipX-hl*Math.cos(ang), baseY=tipY-hl*Math.sin(ang);

    ctx.save();
    ctx.globalAlpha=active?0.85:0.2;

    // Shaft from centre to arrowhead base
    ctx.strokeStyle=col; ctx.lineWidth=lw;
    ctx.beginPath(); ctx.moveTo(cen.sx,cen.sy); ctx.lineTo(baseX,baseY); ctx.stroke();

    // Filled arrowhead
    if(active){
      // Hover glow ring around arrowhead tip
      if(hovered===n.idx){
        ctx.globalAlpha=0.25;
        ctx.beginPath(); ctx.arc(tipX,tipY,13,0,Math.PI*2);
        ctx.fillStyle=col; ctx.fill();
        ctx.globalAlpha=0.85;
      }
      ctx.fillStyle=col;
      ctx.beginPath();
      ctx.moveTo(tipX,tipY);
      ctx.lineTo(tipX-hl*Math.cos(ang-hw), tipY-hl*Math.sin(ang-hw));
      ctx.lineTo(tipX-hl*0.4*Math.cos(ang), tipY-hl*0.4*Math.sin(ang)); // slight concave notch
      ctx.lineTo(tipX-hl*Math.cos(ang+hw), tipY-hl*Math.sin(ang+hw));
      ctx.closePath(); ctx.fill();
    } else {
      // Inactive: small simple triangle
      ctx.fillStyle=col;
      ctx.beginPath();
      ctx.moveTo(tipX,tipY);
      ctx.lineTo(tipX-hl*Math.cos(ang-hw), tipY-hl*Math.sin(ang-hw));
      ctx.lineTo(tipX-hl*Math.cos(ang+hw), tipY-hl*Math.sin(ang+hw));
      ctx.closePath(); ctx.fill();
    }
    ctx.restore();


  });

  // Axis arrows
  const axLen=1.38;
  [['x',axLen,0,0,'#f97316'],['y',0,axLen,0,'#4ade80'],['z',0,0,axLen,'#00d4ff']].forEach(([lbl,ax,ay,az,c])=>{
    const p=project(ax,ay,az,cx,cy,scale);
    ctx.strokeStyle=c; ctx.lineWidth=1.5; ctx.globalAlpha=0.65;
    ctx.beginPath(); ctx.moveTo(cen.sx,cen.sy); ctx.lineTo(p.sx,p.sy); ctx.stroke();
    ctx.globalAlpha=1; ctx.fillStyle=c; ctx.font='bold 11px Space Mono,monospace';
    ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(lbl,p.sx,p.sy);
  });
  ctx.globalAlpha=1;
}

function hitTest(mx,my) {
  const canvas=document.getElementById('d3q27Canvas'); if(!canvas) return null;
  const W2=canvas.width,H=canvas.height,cx=W2/2,cy=H/2,scale=W2*0.18;
  const rect=canvas.getBoundingClientRect();
  const px=(mx-rect.left)*(W2/rect.width), py=(my-rect.top)*(H/rect.height);
  let best=null,bestD=Infinity;
  NODES.forEach((n,i)=>{
    if(!inStencil(n)) return;
    const p=project(n.dx,n.dy,n.dz,cx,cy,scale);
    const d=Math.hypot(p.sx-px,p.sy-py);
    // Hit zone at arrowhead tip (14px) or centre dot (12px)
    const r=(n.dx===0&&n.dy===0&&n.dz===0)?12:14;
    if(d<r&&d<bestD){bestD=d;best=i;}
  });
  return best;
}

function updateDesc() {
  const el=document.getElementById('d3q27StencilDesc'); if(!el) return;
  const s=STENCILS[activeStencil];
  const types=s.types;
  const counts={0:0,1:0,2:0,3:0};
  NODES.forEach(n=>{ if(types.includes(n.type)) counts[n.type]++; });
  const total=Object.values(counts).reduce((a,b)=>a+b,0);
  const parts=types.map(t=>`<span style="color:${TYPE_COLOR[t]}">${counts[t]} ${TYPE_LABEL[t]}${counts[t]>1?'s':''}</span>`).join(' + ');
  el.innerHTML=`<strong style="color:var(--accent)">${s.label}</strong>: ${parts} = <strong style="color:var(--text)">${total} velocities</strong><br><span style="color:var(--text-dim);font-size:9.5px;">${s.desc.split('\n')[1]||''}</span>`;
}

function updateInfo(idx) {
  const el=document.getElementById('d3q27Info'); if(!el) return;
  if(idx===null){
    el.innerHTML='<div style="color:var(--accent);font-size:10px;letter-spacing:1px;margin-bottom:8px;">NODE INFO</div><div>Hover a node to inspect</div>';
    return;
  }
  const n=NODES[idx];
  const s=STENCILS[activeStencil];
  const active=inStencil(n);
  const speed=Math.sqrt(n.dx*n.dx+n.dy*n.dy+n.dz*n.dz).toFixed(2);
  el.innerHTML=`
    <div style="color:var(--accent);font-size:10px;letter-spacing:1px;margin-bottom:8px;">NODE INFO</div>
    <div>e = (${n.dx}, ${n.dy}, ${n.dz})</div>
    <div>type: <span style="color:${TYPE_COLOR[n.type]}">${TYPE_LABEL[n.type]}</span></div>
    <div>|e| = ${speed}</div>
    <div style="margin-top:8px;font-size:10px;color:var(--text-dim);">In D3Q15: <span style="color:${STENCILS[15].types.includes(n.type)?'#4ade80':'#ff4466'}">${STENCILS[15].types.includes(n.type)?'‚úì':'‚úó'}</span></div>
    <div style="font-size:10px;color:var(--text-dim);">In D3Q19: <span style="color:${STENCILS[19].types.includes(n.type)?'#4ade80':'#ff4466'}">${STENCILS[19].types.includes(n.type)?'‚úì':'‚úó'}</span></div>
    <div style="font-size:10px;color:var(--text-dim);">In D3Q27: <span style="color:#4ade80">‚úì</span></div>
  `;
}

// ‚îÄ‚îÄ Public controls ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
window.d3q27SetStencil = function(q) {
  activeStencil=q;
  [15,19,27].forEach(n=>{
    const b=document.getElementById('d3q27Btn'+n);
    if(b) b.classList.toggle('active-layer',n===q);
  });
  updateDesc(); updateInfo(hovered); drawD3Q27();
};


window.d3q27Reset = function() {
  rotX=0.42; rotY=-0.55;
  activeStencil=27;
  [15,19,27].forEach(n=>{const b=document.getElementById('d3q27Btn'+n);if(b)b.classList.toggle('active-layer',n===27);});
  hovered=null; updateInfo(null); updateDesc(); drawD3Q27();
};

// ‚îÄ‚îÄ Mouse / touch ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
window.d3q27MouseDown = function(e){ dragging=true; lastMX=e.clientX; lastMY=e.clientY; e.preventDefault(); };
window.d3q27MouseUp   = function(){ dragging=false; };
window.d3q27MouseMove = function(e){
  const canvas=document.getElementById('d3q27Canvas');
  if(dragging){
    rotY+=(e.clientX-lastMX)*0.012; rotX+=(e.clientY-lastMY)*0.012;
    rotX=Math.max(-Math.PI/2+0.05,Math.min(Math.PI/2-0.05,rotX));
    lastMX=e.clientX; lastMY=e.clientY; drawD3Q27();
  } else {
    const h=hitTest(e.clientX,e.clientY);
    if(h!==hovered){ hovered=h; updateInfo(h); drawD3Q27(); }
    if(canvas) canvas.style.cursor=h!==null?'pointer':'grab';
  }
};
window.d3q27TouchStart=function(e){const t=e.touches[0];lastMX=t.clientX;lastMY=t.clientY;dragging=true;e.preventDefault();};
window.d3q27TouchMove =function(e){if(!dragging)return;const t=e.touches[0];d3q27MouseMove({clientX:t.clientX,clientY:t.clientY});e.preventDefault();};

// ‚îÄ‚îÄ Auto-rotate ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let d3q27RAF=null;
function d3q27AutoRotate(){ if(!dragging){ rotY+=0.003; drawD3Q27(); } d3q27RAF=requestAnimationFrame(d3q27AutoRotate); }

document.addEventListener('DOMContentLoaded',()=>{
  const wait=setInterval(()=>{
    if(document.getElementById('d3q27Canvas')){
      clearInterval(wait); updateDesc(); drawD3Q27(); d3q27RAF=requestAnimationFrame(d3q27AutoRotate);
    }
  },200);
});

})(); // end D3Q27 IIFE


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// GAUSS‚ÄìHERMITE QUADRATURE ANIMATION (sec1b)
// Single global time hqGT ‚àà [0, 4] drives everything.
// Each "phase" is a time window [k, k+1].
// Drawing functions keep all previous content visible at full opacity ‚Äî
// no wipe, no fade-out between steps.
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let hqRunning  = false;
let hqGT       = 0;      // global time 0 ‚Üí 4  (phase k = floor(hqGT))
let hqSpeed    = 1.0;
let hqLastTs   = null;
let hqRAF      = null;
let hqPauseT   = 0;      // countdown for 5-second hold after D3Q27 completes
const HQ_RESTART_PAUSE = 5;

// Phase durations (seconds)
const HQ_DUR = [5, 4, 5, 6];
// Total normalised time units
// hqGT maps linearly within each phase: phase k runs from k‚Üík+1 in "phase units"
// but in real seconds it's HQ_DUR[k]. We handle this via per-phase dt scaling.

const HQ_PHASES = [
  {
    title: 'PHASE 1 ‚Äî He‚ÇÉ(Œæ) ROOTS',
    body:  'The 3-point Gauss‚ÄìHermite rule uses roots of He‚ÇÉ(Œæ) = Œæ¬≥ ‚àí 3Œæ. The three roots ‚àí‚àö3, 0, +‚àö3 become the D1Q3 quadrature nodes after rescaling.',
    math:  'He_3(\\xi)=\\xi^3-3\\xi,\\quad \\xi\\in\\{-\\sqrt{3},\\,0,\\,+\\sqrt{3}\\}'
  },
  {
    title: 'PHASE 2 ‚Äî D1Q3',
    body:  'The roots ¬±‚àö3 are divided by ‚àö3 to give lattice units {‚àí1, 0, +1}. The three rescaled nodes become velocity arrows: the D1Q3 stencil.',
    math:  '\\frac{\\pm\\sqrt{3}}{\\sqrt{3}}=\\pm 1 \\quad\\Rightarrow\\quad e_x\\in\\{-1,\\,0,\\,+1\\}'
  },
  {
    title: 'PHASE 3 ‚Äî ‚äó = D2Q9',
    body:  'A second D1Q3 along y unfolds from the x-axis. Each x-arrow clones into a column, giving 3√ó3 = 9 velocities: D2Q9.',
    math:  'D1Q3\\otimes D1Q3=D2Q9'
  },
  {
    title: 'PHASE 4 ‚Äî ‚äó = D3Q27',
    body:  'A third D1Q3 along z extrudes out of the xy-plane. Each D2Q9 arrow fans into 3 z-copies, giving 9√ó3 = 27 velocities: D3Q27.',
    math:  'D2Q9\\otimes D1Q3=D3Q27'
  }
];

// ‚îÄ‚îÄ Easing ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function easeInOut(t) { return 0.5 - 0.5*Math.cos(t*Math.PI); }
function easeOut(t)   { return 1 - Math.pow(1-t, 2); }
function easeIn(t)    { return t*t; }
function clamp01(t)   { return Math.max(0, Math.min(1, t)); }
// Smooth appear/disappear of a value using eased window [t0, t1]
function smoothStep(t, t0, t1) { return easeInOut(clamp01((t-t0)/(t1-t0))); }

// ‚îÄ‚îÄ Arrow helper ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function hqArrowFull(ctx, ox, oy, tx, ty, col, alpha, lw) {
  if (alpha <= 0) return;
  const ang = Math.atan2(ty-oy, tx-ox);
  const len = Math.hypot(tx-ox, ty-oy);
  if (len < 4) return;
  const hl = Math.min(11, len*0.32), hw = 0.38;
  ctx.save(); ctx.globalAlpha = alpha;
  ctx.strokeStyle = col; ctx.lineWidth = lw ?? 2;
  ctx.beginPath(); ctx.moveTo(ox, oy);
  ctx.lineTo(tx - hl*Math.cos(ang), ty - hl*Math.sin(ang)); ctx.stroke();
  ctx.fillStyle = col;
  ctx.beginPath();
  ctx.moveTo(tx, ty);
  ctx.lineTo(tx - hl*Math.cos(ang-hw), ty - hl*Math.sin(ang-hw));
  ctx.lineTo(tx - hl*0.28*Math.cos(ang), ty - hl*0.28*Math.sin(ang));
  ctx.lineTo(tx - hl*Math.cos(ang+hw), ty - hl*Math.sin(ang+hw));
  ctx.closePath(); ctx.fill();
  ctx.restore();
}

// Thin axis arrow
function hqAxisLine(ctx, ox, oy, tx, ty, col, alpha) {
  if (alpha <= 0) return;
  const ang = Math.atan2(ty-oy, tx-ox), hl=8, hw=0.3;
  ctx.save(); ctx.globalAlpha = alpha;
  ctx.strokeStyle = col; ctx.lineWidth = 1.2;
  ctx.beginPath(); ctx.moveTo(ox,oy);
  ctx.lineTo(tx-hl*Math.cos(ang), ty-hl*Math.sin(ang)); ctx.stroke();
  ctx.fillStyle = col;
  ctx.beginPath(); ctx.moveTo(tx,ty);
  ctx.lineTo(tx-hl*Math.cos(ang-hw), ty-hl*Math.sin(ang-hw));
  ctx.lineTo(tx-hl*Math.cos(ang+hw), ty-hl*Math.sin(ang+hw));
  ctx.closePath(); ctx.fill();
  ctx.restore();
}

function hqLbl(ctx, txt, x, y, col, alpha, sz, align, base) {
  if (alpha <= 0) return;
  ctx.save(); ctx.globalAlpha = alpha;
  ctx.fillStyle=col; ctx.font=(sz??11)+'px Space Mono,monospace';
  ctx.textAlign=align??'center'; ctx.textBaseline=base??'middle';
  ctx.fillText(txt,x,y); ctx.restore();
}

function hqRestDot(ctx, x, y, col, alpha) {
  if (alpha <= 0) return;
  ctx.save(); ctx.globalAlpha=alpha*0.22;
  ctx.beginPath(); ctx.arc(x,y,13,0,Math.PI*2);
  ctx.fillStyle=col; ctx.fill(); ctx.restore();
  ctx.save(); ctx.globalAlpha=alpha;
  ctx.beginPath(); ctx.arc(x,y,7,0,Math.PI*2);
  ctx.fillStyle=col; ctx.fill();
  ctx.strokeStyle='rgba(255,255,255,0.3)'; ctx.lineWidth=1; ctx.stroke();
  ctx.restore();
}

const HQC_REST='#00d4ff', HQC_FACE='#4ade80', HQC_EDGE='#f97316', HQC_CORN='#a78bfa';
function hqTypeColor(n) {
  return n===0?HQC_REST:(n===1?HQC_FACE:(n===2?HQC_EDGE:HQC_CORN));
}

// Shared layout ‚Äî identical across all phases so content aligns
function hqLay(W,H) {
  return { ox:W*0.5, oy:H*0.58, sp:Math.min(W,H)*0.175 };
}

// 3D isometric projection
const HQ_ROT_X=0.42, HQ_ROT_Y=-0.45;
function hqProject(x,y,z,cx,cy,scale) {
  const cosY=Math.cos(HQ_ROT_Y), sinY=Math.sin(HQ_ROT_Y);
  const cosX=Math.cos(HQ_ROT_X), sinX=Math.sin(HQ_ROT_X);
  const rx=x*cosY-z*sinY, ry2=z*cosY+x*sinY;
  const ry=y*cosX-ry2*sinX;
  return {sx:cx+rx*scale, sy:cy-ry*scale};
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MASTER DRAW ‚Äî called every frame with global time gt ‚àà [0,4]
// Each layer checks gt and draws what it should contribute.
// Nothing is ever erased ‚Äî layers accumulate.
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function hqDraw(ctx, W, H, gt) {
  const {ox, oy, sp} = hqLay(W, H);

  // Local phase progress helpers:
  // p0 = progress within phase 0 (0‚Üí1 as gt goes 0‚Üí1)
  const p0 = clamp01(gt);
  const p1 = clamp01(gt - 1);
  const p2 = clamp01(gt - 2);
  const p3 = clamp01(gt - 3);

  // ‚îÄ‚îÄ LAYER 0: He‚ÇÉ polynomial curve ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Fades out gently once D1Q3 (phase 1) is established (gt > 1.3)
  // so it doesn't clutter the later 2D/3D views.
  const scx=sp*1.05, scy=sp*0.88;
  const curveAlpha = p0 * (1 - smoothStep(gt, 1.2, 1.9)) * 0.85;
  const axisAlpha0 = p0 * (1 - smoothStep(gt, 1.2, 1.9)) * 0.45;

  if (curveAlpha > 0.01) {
    // Ghost axes for polynomial plot
    hqAxisLine(ctx, ox-scx*1.5, oy, ox+scx*1.55, oy, '#aaa', axisAlpha0);
    hqAxisLine(ctx, ox, oy+scy*1.5, ox, oy-scy*1.75, '#aaa', axisAlpha0);
    hqLbl(ctx,'Œæ', ox+scx*1.6, oy, '#aaa', axisAlpha0, 12,'left','middle');
    hqLbl(ctx,'He‚ÇÉ(Œæ)', ox, oy-scy*1.8, '#aaa', axisAlpha0, 11,'center','bottom');

    // Curve draws itself
    const cp = easeInOut(clamp01(p0*1.9));
    ctx.save(); ctx.globalAlpha=curveAlpha;
    ctx.strokeStyle='#00d4ff'; ctx.lineWidth=2.5;
    ctx.shadowColor='#00d4ff'; ctx.shadowBlur=6;
    ctx.beginPath(); let started=false;
    for (let i=0;i<=180;i++) {
      const frac=i/180; if(frac>cp) break;
      const xi=-1.78+frac*3.56, yi=xi*xi*xi-3*xi;
      const px=ox+xi*scx*0.76, py=oy-yi*scy*0.4;
      if(!started){ctx.moveTo(px,py);started=true;}else ctx.lineTo(px,py);
    }
    ctx.stroke(); ctx.restore();
    hqLbl(ctx,'He‚ÇÉ(Œæ) = Œæ¬≥ ‚àí 3Œæ', ox, oy-scy*1.52, 'rgba(0,212,255,0.75)', curveAlpha, 12,'center','bottom');
  }

  // ‚îÄ‚îÄ LAYER 0b: Roots appear as dots on polynomial axis ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Timeline within gt:
  //   0.42‚Äì0.85  : dots drop onto the polynomial x-axis at ¬±‚àö3 positions
  //   0.85‚Äì1.10  : "√∑ ‚àö3" annotation appears; dots slide inward to ¬±1 (=¬±sp)
  //   1.10‚Äì1.35  : label morphs ¬±‚àö3 ‚Üí ¬±1; dot converts to arrow tip
  //   1.35+      : dots fully gone, arrows take over
  const roots=[-Math.sqrt(3),0,Math.sqrt(3)];
  const rcols=[HQC_FACE,HQC_REST,HQC_FACE];

  // Positions: raw polynomial x-pos and target lattice x-pos
  const rootRawX  = roots.map(r => ox + r*scx*0.76);   // ¬±‚àö3 on screen
  const rootLatX  = [ox-sp, ox, ox+sp];                  // ¬±1 lattice pos

  // slide progress: 0 at root pos, 1 at lattice pos
  const slide = easeInOut(smoothStep(gt, 0.85, 1.12));

  roots.forEach((r,i)=>{
    const appear = easeOut(clamp01((p0-0.42-i*0.1)*4.5));
    if(appear<=0.01) return;

    // Interpolated dot x-position
    const dotX = rootRawX[i] + (rootLatX[i]-rootRawX[i])*slide;

    // Dot fades out once the arrow fully grows (gt 1.3‚Üí1.5)
    const dotAlpha = appear * (1 - smoothStep(gt, 1.3, 1.5));

    if(dotAlpha>0.01) {
      // Dashed drop-line (fades as curve fades)
      const lineA = dotAlpha * (1-slide) * 0.5;
      if(lineA>0.01) {
        ctx.save(); ctx.globalAlpha=lineA; ctx.strokeStyle=rcols[i]; ctx.lineWidth=1;
        ctx.setLineDash([4,4]);
        ctx.beginPath(); ctx.moveTo(dotX,oy-2); ctx.lineTo(dotX,oy+16); ctx.stroke();
        ctx.restore();
      }
      hqRestDot(ctx, dotX, oy, rcols[i], dotAlpha);

      // Label: shows "¬±‚àö3" before slide, "¬±1" after, with a "√∑‚àö3" hint in between
      if(i!==1) {
        const sign = i===0 ? '‚àí' : '+';
        // Pre-slide: show ¬±‚àö3
        const preA  = dotAlpha * (1 - smoothStep(gt, 0.83, 1.0));
        if(preA>0.01) hqLbl(ctx, sign+'‚àö3', dotX, oy+22, rcols[i], preA, 10,'center','top');
        // Post-slide: show ¬±1
        const postA = dotAlpha * smoothStep(gt, 1.08, 1.28);
        if(postA>0.01) hqLbl(ctx, sign+'1', rootLatX[i], oy+22, rcols[i], postA, 10,'center','top');
      } else {
        hqLbl(ctx,'0', dotX, oy+22, rcols[i], dotAlpha, 10,'center','top');
      }
    }
  });

  // ‚îÄ‚îÄ "√∑ ‚àö3" rescaling annotation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Appears during the slide window, centred above the axis
  {
    const divA = smoothStep(gt, 0.84, 0.97) * (1-smoothStep(gt, 1.18, 1.38));
    if(divA>0.01) {
      // Box background
      ctx.save(); ctx.globalAlpha=divA*0.12;
      ctx.fillStyle='#00d4ff';
      ctx.beginPath(); ctx.roundRect?ctx.roundRect(ox-68,oy-sp*0.68,136,26,4):ctx.rect(ox-68,oy-sp*0.68,136,26);
      ctx.fill(); ctx.restore();
      // Main text
      hqLbl(ctx, 'rescale:  √∑ ‚àö3', ox, oy-sp*0.52, '#00d4ff', divA, 11,'center','middle');
      // Small arrows showing motion direction
      [-1,1].forEach(dir=>{
        const fromX=ox+dir*Math.sqrt(3)*scx*0.76, toX=ox+dir*sp;
        ctx.save(); ctx.globalAlpha=divA*0.5; ctx.strokeStyle=dir<0?HQC_FACE:HQC_FACE; ctx.lineWidth=1;
        ctx.setLineDash([3,4]);
        ctx.beginPath(); ctx.moveTo(fromX,oy-20); ctx.lineTo(toX,oy-20); ctx.stroke();
        ctx.restore();
        // Small arrowhead on the dashed line
        const ang=dir<0?Math.PI:0, hl=5, hw=0.4;
        ctx.save(); ctx.globalAlpha=divA*0.55; ctx.fillStyle=HQC_FACE;
        ctx.beginPath();
        ctx.moveTo(toX,oy-20);
        ctx.lineTo(toX-hl*Math.cos(ang-hw),oy-20-hl*Math.sin(ang-hw));
        ctx.lineTo(toX-hl*Math.cos(ang+hw),oy-20-hl*Math.sin(ang+hw));
        ctx.closePath(); ctx.fill(); ctx.restore();
      });
    }
  }

  // ‚îÄ‚îÄ LAYER 1: x-axis (permanent from phase 1 onward) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const xAxisAlpha = smoothStep(gt, 0.9, 1.3) * 0.6;
  const xAxisFinal = xAxisAlpha * (1 - smoothStep(gt, 3.0, 3.4));
  hqAxisLine(ctx, ox-sp*1.6, oy, ox+sp*1.65, oy, '#f97316', xAxisFinal);
  hqLbl(ctx,'e‚Çì', ox+sp*1.7, oy, '#f97316', xAxisFinal, 12,'left','middle');

  // ‚îÄ‚îÄ LAYER 1b: D1Q3 ‚Äî rest dot + ¬±x arrows ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Arrows grow after the dots have slid into place (gt > 1.3)
  const d1Fade = 1 - smoothStep(gt, 3.0, 3.4);
  const d1Base = p1;
  if (d1Base > 0 && d1Fade > 0) {
    // rest dot
    hqRestDot(ctx, ox, oy, HQC_REST, easeOut(clamp01(p1*5)) * d1Fade);

    // ¬±1 arrows ‚Äî only start growing once slide is nearly done (gt > 1.28)
    [[-1,'‚àí1'],[1,'+1']].forEach(([dx,lbl],i)=>{
      const startGT = 1.28 + i*0.08;
      const a = easeOut(clamp01((gt - startGT)*3.5)) * d1Fade;
      if(a<=0) return;
      hqArrowFull(ctx, ox,oy, ox+dx*sp,oy, HQC_FACE, a, 2.5);
    });
  }

  // ‚îÄ‚îÄ LAYER 1 title: D1Q3 label ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const d1TitleA = easeOut(clamp01(p1*4)) * (1 - smoothStep(gt, 2.0, 2.4));
  hqLbl(ctx,'D1Q3', ox, oy-sp*1.55, '#00d4ff', d1TitleA, 16,'center','bottom');

  // ‚îÄ‚îÄ LAYER 2: y-axis unfolds ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const yU = easeInOut(clamp01(p2*3));
  const yAxisFade = 1 - smoothStep(gt, 3.0, 3.4);
  if(yU>0.01 && yAxisFade>0) {
    hqAxisLine(ctx,ox,oy, ox,oy-sp*1.6*yU, '#4ade80', yU*0.55*yAxisFade);
    hqLbl(ctx,'e·µß', ox, oy-sp*1.65*yU, '#4ade80', yU*0.55*yAxisFade, 12,'center','bottom');
    hqAxisLine(ctx,ox,oy, ox,oy+sp*1.6*yU, '#4ade80', yU*0.3*yAxisFade);
  }

  // ‚îÄ‚îÄ LAYER 2b: D2Q9 ‚Äî new dy‚â†0 arrows fan out ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const d2Fade = 1 - smoothStep(gt, 3.0, 3.4);
  if(p2>0 && d2Fade>0) {
    const D1=[-1,0,1];
    D1.forEach((dy)=>{
      if(dy===0) return; // dy=0 row already drawn in layer 1
      D1.forEach((dx,i)=>{
        const rowDelay=0.18+Math.abs(dy)*0.05;
        const nodeDelay=rowDelay+i*0.045;
        const rawA=easeOut(clamp01((p2-nodeDelay)*3));
        const a=rawA*yU*d2Fade;
        if(a<=0) return;
        const n=Math.abs(dx)+Math.abs(dy);
        const col=hqTypeColor(n);
        // Tip grows along y proportional to yU and rawA
        const animTy=oy-(dy*sp*clamp01(rawA*1.6)*yU);
        hqArrowFull(ctx,ox,oy, ox+dx*sp,animTy, col,a*0.9,2);
      });
    });
    // ‚äó symbol
    const symA=p2>0.05&&p2<0.5?Math.sin(Math.PI*clamp01((p2-0.05)/0.45))*0.55*d2Fade:0;
    if(symA>0) hqLbl(ctx,'‚äó', ox+sp*2.1, oy, '#00d4ff', symA, 30,'center','middle');
  }

  // D2Q9 title + count (fades out before phase 3 title appears)
  const d2TitleA = easeOut(clamp01(p2*4)) * (1 - smoothStep(gt, 2.9, 3.3));
  hqLbl(ctx,'D1Q3 ‚äó D1Q3 = D2Q9', ox, oy-sp*1.78, '#00d4ff', d2TitleA, 13,'center','bottom');
  const d2CountA = clamp01(p2-0.55)*5 * (1-smoothStep(gt,2.9,3.3));
  hqLbl(ctx,'3 √ó 3 = 9 velocities', ox, oy+sp*1.15, 'rgba(255,255,255,0.4)', d2CountA, 10,'center','top');

  // ‚îÄ‚îÄ LAYER 3: isometric projection ‚Äî z-axis extrudes, D3Q27 ‚îÄ‚îÄ‚îÄ‚îÄ
  if(p3>0) {
    const cx=W*0.5, cy=H*0.55;
    const scale=Math.min(W,H)*0.162;
    const zU=easeInOut(clamp01(p3*3));
    const cen=hqProject(0,0,0,cx,cy,scale);

    // Title
    const d3TitleA=easeOut(clamp01(p3*4));
    hqLbl(ctx,'D2Q9 ‚äó D1Q3 = D3Q27', cx, cy-scale*1.72, '#00d4ff', d3TitleA, 13,'center','bottom');

    // Faint bounding box
    ctx.save(); ctx.globalAlpha=clamp01(p3*4)*0.18;
    ctx.strokeStyle='rgba(60,100,150,1)'; ctx.lineWidth=0.8;
    const corn=[[-1,-1,-1],[1,-1,-1],[1,1,-1],[-1,1,-1],[-1,-1,1],[1,-1,1],[1,1,1],[-1,1,1]];
    const edgs=[[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
    const cps=corn.map(([x,y,z])=>hqProject(x,y,z,cx,cy,scale));
    edgs.forEach(([a,b])=>{ctx.beginPath();ctx.moveTo(cps[a].sx,cps[a].sy);ctx.lineTo(cps[b].sx,cps[b].sy);ctx.stroke();});
    ctx.restore();

    // Axis labels (isometric)
    ctx.save(); ctx.globalAlpha=clamp01(p3*3)*0.6;
    [['e‚Çì',1.5,0,0,'#f97316'],['e·µß',0,1.5,0,'#4ade80'],['e_z',0,0,1.5,'#00d4ff']].forEach(([lbl,ax,ay,az,c])=>{
      const pp=hqProject(ax,ay,az*zU,cx,cy,scale);
      ctx.strokeStyle=c; ctx.lineWidth=1.2;
      ctx.beginPath(); ctx.moveTo(cen.sx,cen.sy); ctx.lineTo(pp.sx,pp.sy); ctx.stroke();
      ctx.fillStyle=c; ctx.font='11px Space Mono,monospace';
      ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(lbl,pp.sx,pp.sy);
    });
    ctx.restore();

    // All 27 arrows depth-sorted
    const D1=[-1,0,1];
    const all=[];
    D1.forEach(dz=>D1.forEach(dy=>D1.forEach(dx=>{
      const n=Math.abs(dx)+Math.abs(dy)+Math.abs(dz);
      const {sx:sdx,sy:sdy}=hqProject(dx,dy,dz,cx,cy,scale);
      all.push({dx,dy,dz,n,depth:sdx*0.1-sdy});
    })));
    all.sort((a,b)=>a.depth-b.depth);

    all.forEach(v=>{
      const layerD=v.dz===0?0:(0.1+Math.abs(v.dz)*0.07);
      const nodeD=layerD+((v.dx+1)*3+(v.dy+1))/27*0.28;
      const rawA=easeOut(clamp01((p3-nodeD)*3.5));
      const a=v.dz===0?rawA:rawA*zU;
      if(a<=0) return;
      const col=hqTypeColor(v.n);
      if(v.n===0) {
        hqRestDot(ctx,cen.sx,cen.sy,col,a);
      } else {
        const tipP=v.dz===0
          ? hqProject(v.dx,v.dy,0,cx,cy,scale)
          : hqProject(v.dx,v.dy,v.dz*clamp01(rawA*1.8)*zU,cx,cy,scale);
        hqArrowFull(ctx,cen.sx,cen.sy,tipP.sx,tipP.sy,col,a*0.88,1.6);
      }
    });

    // ‚äó symbol
    const symA=p3>0.05&&p3<0.48?Math.sin(Math.PI*clamp01((p3-0.05)/0.43))*0.5:0;
    if(symA>0){
      const zp=hqProject(0,0,1.85*zU,cx,cy,scale);
      hqLbl(ctx,'‚äó',zp.sx+16,zp.sy,'#00d4ff',symA,28,'center','middle');
    }
    const d3CountA=clamp01((p3-0.55)*5);
    hqLbl(ctx,'9 √ó 3 = 27 velocities', cx, cy+scale*1.5, 'rgba(255,255,255,0.4)', d3CountA, 10,'center','top');
  }

  // ‚îÄ‚îÄ Phase progress dots ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const curPhase = Math.min(3, Math.floor(gt));
  ctx.save();
  for(let k=0;k<4;k++){
    const active=k===curPhase;
    const done=k<curPhase;
    ctx.beginPath(); ctx.arc(W/2-30+k*20, H-10, active?4:2.5, 0, Math.PI*2);
    ctx.fillStyle=active?'#00d4ff':(done?'rgba(0,212,255,0.5)':'rgba(0,212,255,0.2)');
    ctx.fill();
  }
  ctx.restore();
}

// ‚îÄ‚îÄ Render (called every frame) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function hqRender(dt) {
  const canvas=document.getElementById('hqCanvas'); if(!canvas) return;
  const ctx=canvas.getContext('2d');
  const W=canvas.width, H=canvas.height;
  ctx.fillStyle='#070b12'; ctx.fillRect(0,0,W,H);

  if(hqPauseT<=0) {
    // Advance global time, scaled by per-phase duration
    const phase=Math.min(3,Math.floor(hqGT));
    hqGT += dt * hqSpeed / HQ_DUR[phase];
    if(hqGT>4) hqGT=4;
  }

  hqDraw(ctx, W, H, hqGT);

  // Countdown text during pause
  if(hqPauseT>0) {
    ctx.save();
    ctx.fillStyle='rgba(0,212,255,0.22)';
    ctx.font='9px Space Mono,monospace';
    ctx.textAlign='right'; ctx.textBaseline='bottom';
    ctx.fillText('restarting in '+Math.ceil(hqPauseT)+'s‚Ä¶', W-10, H-6);
    ctx.restore();
  }
}

// ‚îÄ‚îÄ Update sidebar UI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function hqUpdateUI() {
  const phase = Math.min(3, Math.floor(hqGT));
  const ph = HQ_PHASES[phase];
  const titleEl=document.getElementById('hqInfoTitle');
  const bodyEl=document.getElementById('hqInfoBody');
  const mathEl=document.getElementById('hqInfoMath');
  if(titleEl) titleEl.textContent=ph.title;
  if(bodyEl)  bodyEl.textContent=ph.body;
  if(mathEl) {
    if(typeof katex!=='undefined'){
      try{katex.render(ph.math,mathEl,{throwOnError:false,displayMode:true});}
      catch(e){mathEl.textContent=ph.math;}
    } else mathEl.textContent=ph.math;
  }
  for(let k=0;k<4;k++){
    const btn=document.getElementById('hqBtn'+k);
    if(btn) btn.classList.toggle('active-phase',k===phase);
    const track=document.getElementById('hqT'+k);
    if(track) track.classList.toggle('active-track',k===phase);
  }
}

// ‚îÄ‚îÄ Loop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function hqLoop(ts) {
  if(!hqRunning){hqRAF=null;return;}
  const dt=hqLastTs!==null?Math.min((ts-hqLastTs)/1000,0.1):0;
  hqLastTs=ts;

  if(hqPauseT>0){
    hqPauseT-=dt*hqSpeed;
    hqRender(0);
    if(hqPauseT<=0){hqPauseT=0;hqGT=0;hqUpdateUI();}
  } else {
    hqRender(dt);
    const prevPhase=Math.min(3,Math.floor(Math.max(0,hqGT-0.001)));
    const curPhase=Math.min(3,Math.floor(hqGT));
    if(curPhase!==prevPhase) hqUpdateUI();
    if(hqGT>=4){ hqPauseT=HQ_RESTART_PAUSE; }
  }
  hqRAF=requestAnimationFrame(hqLoop);
}

function hqStart(){
  if(hqRAF) return;
  hqLastTs=null;
  hqRAF=requestAnimationFrame(hqLoop);
}

// ‚îÄ‚îÄ Public controls ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function hqToggle(){
  hqRunning=!hqRunning;
  const btn=document.getElementById('hqPauseBtn');
  if(btn) btn.textContent=hqRunning?'‚ñ† PAUSE':'‚ñ∂ PLAY';
  if(hqRunning) hqStart();
}

function hqGoPhase(k){
  hqGT=k; hqPauseT=0;
  hqUpdateUI();
  hqRunning=false;
  const btn=document.getElementById('hqPauseBtn');
  if(btn) btn.textContent='‚ñ∂ PLAY';
  const canvas=document.getElementById('hqCanvas');
  if(canvas){
    const ctx=canvas.getContext('2d');
    ctx.fillStyle='#070b12';ctx.fillRect(0,0,canvas.width,canvas.height);
    hqDraw(ctx,canvas.width,canvas.height,hqGT);
  }
}

function hqReset(){
  hqGT=0; hqPauseT=0;
  hqUpdateUI();
  hqRunning=true;
  const btn=document.getElementById('hqPauseBtn');
  if(btn) btn.textContent='‚ñ† PAUSE';
  if(hqRAF){cancelAnimationFrame(hqRAF);hqRAF=null;}
  hqStart();
}

document.addEventListener('DOMContentLoaded',()=>{
  const spd=document.getElementById('hqSpeedSlider');
  if(spd) spd.addEventListener('input',e=>{hqSpeed=parseFloat(e.target.value);});
  hqUpdateUI();
});

</script>
</body>
</html>
